{
  "hash": "767f317499618fbdd4b15e6894e559a7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tjedan 6: Programiranje u R-u\"\nsubtitle: \"Funkcije, uvjeti i ponovljive analize\"\ndate: 2025-03-29\ncategories: [programiranje, funkcije, if/else, petlje, purrr, ponovljivost]\ndraft: false\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n::: {.callout-note}\n## Ishodi učenja\n\nNakon ovog predavanja moći ćete\n\n1. Objasniti zašto su vlastite funkcije korisne za izbjegavanje ponavljanja koda i smanjenje grešaka.\n2. Napisati vlastitu R funkciju s argumentima i podrazumijevanim (default) vrijednostima.\n3. Koristiti uvjetne naredbe (`if`, `else`, `if_else()`, `case_when()`) za kontrolu toka programa.\n4. Koristiti `for` petlje za ponavljanje operacija nad skupom elemenata.\n5. Koristiti `map()` funkcije iz paketa purrr kao modernu alternativu petljama.\n6. Primijeniti principe DRY (Don't Repeat Yourself) na pisanje analitičkih skripti.\n7. Organizirati analitičku skriptu s jasnom strukturom: učitavanje, čišćenje, analiza, vizualizacija, izvoz.\n8. Prepoznati kada je pisanje vlastite funkcije isplativije od kopiranja koda.\n:::\n\n## Koliko programiranja treba komunikolog?\n\nOvo pitanje zaslužuje iskren odgovor. Ne trebate postati softverski inženjer. Ne trebate znati pisati web aplikacije, baze podataka ili algoritme strojnog učenja. Ali trebate znati dovoljno programiranja da vaše analize budu **ponovljive**, **prilagodljive** i **manje podložne greškama**.\n\nZamislite sljedeću situaciju. Radite analizu medijskih navika za klijenta. Napravili ste čišćenje podataka, deskriptivnu statistiku, osam grafova i izvještaj. Klijent je zadovoljan, ali tjedan dana kasnije kaže: \"Dobili smo još 200 odgovora na anketu, možete li ponoviti analizu s novim podacima?\" Ako ste sve radili ručno u Excelu, to znači ponoviti svaki korak od nule. Ako ste napisali R skriptu, to znači promijeniti jednu liniju koda (putanju do nove datoteke) i pokrenuti skriptu. Pet sekundi umjesto pet sati.\n\nProgramiranje u kontekstu analize podataka nije apstraktno akademsko znanje. To je praktična vještina koja vas čini bržima, preciznijima i profesionalnijima. U ovom tjednu naučit ćemo tri temeljne programerske koncepte (funkcije, uvjetne naredbe i iteraciju) i pokazati kako ih koristiti u kontekstu koji je relevantan za komunikologe.\n\n---\n\n## Naši podaci: newsletter kampanje {#sec-podaci}\n\nOvaj tjedan koristimo dataset o 50 newsletter kampanja jednog informativnog portala. Za svaku kampanju imamo podatke o tipu, stilu naslova, vremenu slanja, broju pretplatnika, open rateu (postotak otvaranja), click rateu (postotak klikova) i drugim metrikama.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnl <- read_csv(\"../resources/datasets/newsletter_campaigns.csv\")\nglimpse(nl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 50\nColumns: 13\n$ campaign_id      <chr> \"NL-001\", \"NL-002\", \"NL-003\", \"NL-004\", \"NL-005\", \"NL…\n$ campaign_type    <chr> \"special_report\", \"weekly_digest\", \"special_report\", …\n$ subject_style    <chr> \"personalizirani\", \"hitno\", \"upitni\", \"informativni\",…\n$ day_sent         <chr> \"petak\", \"petak\", \"utorak\", \"ponedjeljak\", \"utorak\", …\n$ send_hour        <dbl> 8, 11, 8, 9, 20, 16, 13, 6, 11, 19, 11, 19, 9, 15, 18…\n$ subscribers      <dbl> 11770, 14266, 10652, 23113, 9847, 9150, 23450, 12798,…\n$ open_rate        <dbl> 0.2410, 0.2696, 0.3023, 0.2134, 0.2887, 0.1921, 0.288…\n$ click_rate       <dbl> 0.0858, 0.0065, 0.0309, 0.0656, 0.0273, 0.0651, 0.015…\n$ unsubscribe_rate <dbl> 0.00447, 0.00283, 0.00519, 0.00000, 0.00082, 0.00391,…\n$ word_count       <dbl> 499, 378, 437, 545, 559, 146, 428, 210, 309, 519, 376…\n$ n_links          <dbl> 2, 9, 4, 1, 3, 1, 10, 3, 8, 4, 9, 3, 8, 7, 5, 7, 1, 5…\n$ has_image        <lgl> TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALS…\n$ revenue          <dbl> 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 4659.53, 0.…\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnl |>\n  count(campaign_type, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  campaign_type      n\n  <chr>          <int>\n1 special_report    17\n2 weekly_digest     12\n3 sponsored          8\n4 breaking_news      7\n5 event_promo        6\n```\n\n\n:::\n:::\n\n\nOvo je manji dataset od prethodnih tjedana, ali upravo to ga čini pogodnim za učenje programiranja. S 50 redova možete vidjeti svaki korak i razumjeti što vaš kod radi.\n\n---\n\n## Zašto funkcije? Problem kopiranja koda {#sec-zasto-funkcije}\n\nKrenimo od konkretnog problema. Recimo da za svaki tip kampanje želite izračunati sažetak s prosjekom, medijanom i standardnom devijacijom open ratea. Jedan pristup je kopiranje koda.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sažetak za weekly digest\nnl |>\n  filter(campaign_type == \"weekly_digest\") |>\n  summarise(\n    n = n(),\n    or_prosjek = round(mean(open_rate), 3),\n    or_medijan = round(median(open_rate), 3),\n    or_sd = round(sd(open_rate), 3)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n      n or_prosjek or_medijan or_sd\n  <int>      <dbl>      <dbl> <dbl>\n1    12      0.289       0.29 0.066\n```\n\n\n:::\n\n```{.r .cell-code}\n# Sažetak za breaking news (kopiran kod s jednom promjenom)\nnl |>\n  filter(campaign_type == \"breaking_news\") |>\n  summarise(\n    n = n(),\n    or_prosjek = round(mean(open_rate), 3),\n    or_medijan = round(median(open_rate), 3),\n    or_sd = round(sd(open_rate), 3)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n      n or_prosjek or_medijan or_sd\n  <int>      <dbl>      <dbl> <dbl>\n1     7      0.198      0.195 0.055\n```\n\n\n:::\n:::\n\n\nOvo radi, ali ima tri problema. Prvo, ako želite promijeniti izračun (recimo dodati trimmed mean), morate to napraviti na svakom mjestu gdje ste kopirali kod. Drugo, svako kopiranje je prilika za grešku. Možda zaboravite promijeniti ime kampanje na jednom mjestu. Treće, kad imate pet ili deset tipova kampanja, kod postaje nepregledano dugačak.\n\nNaravno, za ovaj specifični problem znamo elegantno rješenje: `group_by()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnl |>\n  group_by(campaign_type) |>\n  summarise(\n    n = n(),\n    or_prosjek = round(mean(open_rate), 3),\n    or_medijan = round(median(open_rate), 3),\n    or_sd = round(sd(open_rate), 3),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  campaign_type      n or_prosjek or_medijan or_sd\n  <chr>          <int>      <dbl>      <dbl> <dbl>\n1 breaking_news      7      0.198      0.195 0.055\n2 event_promo        6      0.25       0.23  0.086\n3 special_report    17      0.259      0.255 0.067\n4 sponsored          8      0.248      0.246 0.043\n5 weekly_digest     12      0.289      0.29  0.066\n```\n\n\n:::\n:::\n\n\nAli `group_by()` ne rješava svaki problem. Kad trebate ponoviti složeniju analizu (koja uključuje čišćenje, više izračuna, graf i tablicu) za različite podskupove podataka, vlastite funkcije postaju nezamjenjive.\n\n---\n\n## Pisanje vlastite funkcije {#sec-funkcije}\n\nFunkcija u R-u je objekt koji prima ulazne podatke (argumente), izvršava niz operacija i vraća rezultat. Već koristite funkcije svaki dan: `mean()`, `filter()`, `ggplot()` su sve funkcije koje je netko napisao. Sad ćete naučiti pisati vlastite.\n\n### Anatomija funkcije\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funkcija koja pretvara postotke u razlomke\npostotak_u_razlomak <- function(postotak) {\n  postotak / 100\n}\n\npostotak_u_razlomak(25)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.25\n```\n\n\n:::\n\n```{.r .cell-code}\npostotak_u_razlomak(73.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.735\n```\n\n\n:::\n:::\n\n\nRaščlanimo sintaksu. `postotak_u_razlomak` je ime funkcije (kao ime bilo kojeg objekta, dodjeljujemo ga s `<-`). Ključna riječ `function()` govori R-u da kreiramo funkciju. Unutar zagrada su argumenti (ulazni podatci). Unutar vitičastih zagrada `{}` je tijelo funkcije (operacije koje se izvršavaju). Zadnji izraz u tijelu je povratna vrijednost (ono što funkcija vraća).\n\n### Funkcija s više argumenata\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funkcija za izračun engagement ratea\nengagement_rate <- function(clicks, opens) {\n  rate <- clicks / opens\n  round(rate, 4)\n}\n\nengagement_rate(clicks = 150, opens = 1200)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.125\n```\n\n\n:::\n\n```{.r .cell-code}\nengagement_rate(clicks = 80, opens = 500)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.16\n```\n\n\n:::\n:::\n\n\nFunkcija prima dva argumenta i vraća zaokruženi omjer. Kad pozivate funkciju, argumente možete navesti po imenu (`clicks = 150`) ili po poziciji. Po imenu je sigurnije jer nije bitno kojim redoslijedom ih navedete.\n\n### Default vrijednosti argumenata\n\nPonekad želite da argument ima podrazumijevanu (default) vrijednost koju korisnik može promijeniti ako želi.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funkcija za sažetak numeričke varijable\nsazetak_varijable <- function(x, decimale = 2) {\n  tibble(\n    n = length(x),\n    n_NA = sum(is.na(x)),\n    prosjek = round(mean(x, na.rm = TRUE), decimale),\n    medijan = round(median(x, na.rm = TRUE), decimale),\n    sd = round(sd(x, na.rm = TRUE), decimale),\n    min = round(min(x, na.rm = TRUE), decimale),\n    max = round(max(x, na.rm = TRUE), decimale)\n  )\n}\n\n# Korištenje s default decimala (2)\nsazetak_varijable(nl$open_rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 7\n      n  n_NA prosjek medijan    sd   min   max\n  <int> <int>   <dbl>   <dbl> <dbl> <dbl> <dbl>\n1    50     0    0.25    0.25  0.07  0.11  0.41\n```\n\n\n:::\n\n```{.r .cell-code}\n# Korištenje s 4 decimale\nsazetak_varijable(nl$open_rate, decimale = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 7\n      n  n_NA prosjek medijan     sd   min   max\n  <int> <int>   <dbl>   <dbl>  <dbl> <dbl> <dbl>\n1    50     0   0.255   0.252 0.0676 0.115 0.408\n```\n\n\n:::\n:::\n\n\nArgument `decimale = 2` ima default vrijednost 2. Ako ga ne navedete pri pozivu, koristi se 2. Ako ga eksplicitno navedete, koristi se vaša vrijednost. Ovo čini funkciju fleksibilnom bez opterećivanja korisnika nepotrebnim odlukama.\n\n### Funkcija koja radi s tibbleom\n\nFunkcije koje primaju cijeli tibble i koriste dplyr glagole unutar sebe su izuzetno korisne u praksi.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funkcija za sažetak kampanje po tipu\nsazetak_kampanje <- function(data, tip) {\n  data |>\n    filter(campaign_type == tip) |>\n    summarise(\n      tip = tip,\n      n = n(),\n      prosjek_or = round(mean(open_rate), 3),\n      prosjek_ctr = round(mean(click_rate), 4),\n      ukupni_doseg = sum(subscribers),\n      .groups = \"drop\"\n    )\n}\n\nsazetak_kampanje(nl, \"weekly_digest\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  tip               n prosjek_or prosjek_ctr ukupni_doseg\n  <chr>         <int>      <dbl>       <dbl>        <dbl>\n1 weekly_digest    12      0.289       0.029       217303\n```\n\n\n:::\n\n```{.r .cell-code}\nsazetak_kampanje(nl, \"breaking_news\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  tip               n prosjek_or prosjek_ctr ukupni_doseg\n  <chr>         <int>      <dbl>       <dbl>        <dbl>\n1 breaking_news     7      0.198      0.0382       120123\n```\n\n\n:::\n:::\n\n\nSad umjesto kopiranja pet blokova koda, pozivamo jednu funkciju s različitim argumentom. Ako želite promijeniti izračun (dodati novu metriku), mijenjate na jednom mjestu i promjena se automatski primjenjuje svugdje.\n\n### Funkcija koja vraća graf\n\nFunkcije mogu vraćati bilo koji R objekt, uključujući ggplot grafove.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraf_distribucije <- function(data, varijabla, naslov) {\n  data |>\n    ggplot(aes(x = .data[[varijabla]])) +\n    geom_histogram(fill = \"steelblue\", color = \"white\", bins = 12) +\n    labs(title = naslov, x = varijabla, y = \"Broj kampanja\") +\n    theme_minimal()\n}\n\ngraf_distribucije(nl, \"open_rate\", \"Distribucija open ratea\")\n```\n\n::: {.cell-output-display}\n![](week-06_files/figure-docx/funkcija-graf-1.png)\n:::\n:::\n\n\nKonstrukcija `.data[[varijabla]]` omogućuje prosljeđivanje imena stupca kao teksta. Ovo je tehnički detalj tidyverse programiranja koji je koristan kad pišete funkcije koje rade s različitim stupcima.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraf_distribucije(nl, \"click_rate\", \"Distribucija click ratea\")\n```\n\n::: {.cell-output-display}\n![](week-06_files/figure-docx/funkcija-graf-2-1.png)\n:::\n:::\n\n\nIsta funkcija, druga varijabla, novi graf. Ovo je suština DRY principa: napišete logiku jednom i koristite je koliko god puta trebate.\n\n::: {.callout-tip}\n## Praktični savjet\n\nPravilo tri: ako ste kopirali isti blok koda tri puta ili više, vrijeme je da ga pretvorite u funkciju. Dva kopiranja su još prihvatljiva (ponekad je brže kopirati nego pisati funkciju), ali tri signaliziraju obrazac koji će se ponavljati i dalje. Funkcija vam štedi vrijeme dugoročno i smanjuje rizik od grešaka pri kopiranju.\n:::\n\n---\n\n## Uvjetne naredbe: if i else {#sec-uvjeti}\n\nUvjetne naredbe omogućuju R-u da donese odluku: ako je uvjet ispunjen, napravi jedno, inače napravi drugo. Već smo koristili `if_else()` i `case_when()` unutar `mutate()` za rekodiranje varijabli. Sad učimo klasične `if`/`else` naredbe koje rade izvan tibble konteksta.\n\n### Osnovna sintaksa\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprosjek_or <- mean(nl$open_rate)\n\nif (prosjek_or > 0.25) {\n  cat(\"Prosječni open rate je iznad 25%, što je odličan rezultat.\\n\")\n} else {\n  cat(\"Prosječni open rate je ispod 25%, ima prostora za poboljšanje.\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nProsječni open rate je iznad 25%, što je odličan rezultat.\n```\n\n\n:::\n:::\n\n\nR evaluira uvjet u zagradi. Ako je TRUE, izvršava kod u prvom bloku. Ako je FALSE, izvršava kod u else bloku. Funkcija `cat()` ispisuje tekst u konzolu (slično `print()`, ali bez dodatnih oznaka).\n\n### if, else if, else\n\nZa više od dva ishoda, koristite `else if`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nocijeni_kampanju <- function(open_rate) {\n  if (open_rate > 0.30) {\n    \"izvrsna\"\n  } else if (open_rate > 0.20) {\n    \"dobra\"\n  } else if (open_rate > 0.10) {\n    \"prosječna\"\n  } else {\n    \"loša\"\n  }\n}\n\nocijeni_kampanju(0.35)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"izvrsna\"\n```\n\n\n:::\n\n```{.r .cell-code}\nocijeni_kampanju(0.22)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"dobra\"\n```\n\n\n:::\n\n```{.r .cell-code}\nocijeni_kampanju(0.08)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"loša\"\n```\n\n\n:::\n:::\n\n\nUvjeti se provjeravaju redom, od vrha prema dnu. Čim je jedan uvjet TRUE, pripadajuća vrijednost se vraća i R ne provjerava preostale uvjete. Zato uvjete postavljamo od najstrožeg prema najblažem.\n\n### Razlika između if/else i if_else()/case_when()\n\nOvo je česta točka zbunjenosti. Postoje dva različita sustava uvjetnog izvršavanja u R-u i svaki ima svoje mjesto.\n\nKlasični `if`/`else` radi s jednom vrijednošću. Koristi se u funkcijama, skriptama i kontroli toka programa. Nije vektoriziran, što znači da ne može obrađivati cijeli stupac odjednom.\n\n`if_else()` i `case_when()` su vektorizirane funkcije. Rade s cijelim vektorom (stupcem) odjednom i koriste se unutar `mutate()` za rekodiranje varijabli u tibbleu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if_else() unutar mutate: radi na cijelom stupcu\nnl |>\n  mutate(\n    ocjena = if_else(open_rate > 0.25, \"iznad prosjeka\", \"ispod prosjeka\")\n  ) |>\n  count(ocjena)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  ocjena             n\n  <chr>          <int>\n1 ispod prosjeka    25\n2 iznad prosjeka    25\n```\n\n\n:::\n\n```{.r .cell-code}\n# Klasični if/else: radi s jednom vrijednošću\n# (koristili smo ga u funkciji ocijeni_kampanju)\n```\n:::\n\n\nPravilo je jednostavno. Unutar `mutate()` koristite `if_else()` ili `case_when()`. Izvan `mutate()`, u funkcijama i skriptama, koristite klasični `if`/`else`.\n\n### Uvjeti u funkcijama: validacija ulaza\n\nPraktična primjena `if`/`else` u funkcijama je provjera jesu li ulazni podaci ispravni.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nizracunaj_ctr <- function(clicks, impressions) {\n  if (impressions <= 0) {\n    warning(\"Broj impresija mora biti pozitivan. Vraćam NA.\")\n    return(NA_real_)\n  }\n  \n  if (clicks < 0) {\n    warning(\"Broj klikova ne može biti negativan. Vraćam NA.\")\n    return(NA_real_)\n  }\n  \n  round(clicks / impressions, 4)\n}\n\nizracunaj_ctr(150, 5000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.03\n```\n\n\n:::\n\n```{.r .cell-code}\nizracunaj_ctr(150, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nizracunaj_ctr(-10, 5000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nFunkcija `warning()` ispisuje upozorenje ali ne zaustavlja izvršavanje. Funkcija `return()` eksplicitno vraća vrijednost i izlazi iz funkcije. Bez `return()`, funkcija bi nastavila izvršavanje i pokušala podijeliti s nulom.\n\nValidacija ulaza je ono što razdvaja robusne funkcije od krhkih. Kad pišete funkciju za sebe, možda znate da nikad nećete unijeti negativan broj. Ali kad tu funkciju koristi netko drugi (ili vi za šest mjeseci, kad ste zaboravili detalje), validacija sprečava tihe greške.\n\n---\n\n## For petlje: ponavljanje operacija {#sec-for}\n\nPetlja je naredba koja ponavlja blok koda za svaki element u skupu. `for` petlja u R-u ima jednostavnu sintaksu.\n\n### Osnovna for petlja\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntipovi <- unique(nl$campaign_type)\n\nfor (tip in tipovi) {\n  n <- nl |> filter(campaign_type == tip) |> nrow()\n  cat(tip, \":\", n, \"kampanja\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspecial_report : 17 kampanja\nweekly_digest : 12 kampanja\nbreaking_news : 7 kampanja\nsponsored : 8 kampanja\nevent_promo : 6 kampanja\n```\n\n\n:::\n:::\n\n\nR prolazi kroz svaki element vektora `tipovi`, dodjeljuje ga varijabli `tip`, i izvršava kod u tijelu petlje. Kad se tijelo izvrši za zadnji element, petlja završava.\n\n### For petlja za generiranje rezultata\n\nČest obrazac je korištenje petlje za prikupljanje rezultata u listu ili tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inicijalizirajte praznu listu za rezultate\nrezultati <- list()\n\nfor (tip in tipovi) {\n  saz <- nl |>\n    filter(campaign_type == tip) |>\n    summarise(\n      tip = tip,\n      n = n(),\n      prosjek_or = round(mean(open_rate), 3),\n      prosjek_ctr = round(mean(click_rate), 4)\n    )\n  \n  rezultati[[tip]] <- saz\n}\n\n# Spojite sve rezultate u jedan tibble\nbind_rows(rezultati)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  tip                n prosjek_or prosjek_ctr\n  <chr>          <int>      <dbl>       <dbl>\n1 special_report    17      0.259      0.0519\n2 weekly_digest     12      0.289      0.029 \n3 breaking_news      7      0.198      0.0382\n4 sponsored          8      0.248      0.0223\n5 event_promo        6      0.25       0.0294\n```\n\n\n:::\n:::\n\n\nKreiramo praznu listu `rezultati`, u svakoj iteraciji računamo sažetak i pohranjujemo ga u listu pod imenom tipa kampanje, a na kraju sve spajamo u jedan tibble s `bind_rows()`.\n\n### For petlja za generiranje grafova\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generiranje grafa za svaki tip kampanje\nfor (tip in c(\"weekly_digest\", \"breaking_news\")) {\n  p <- nl |>\n    filter(campaign_type == tip) |>\n    ggplot(aes(x = open_rate)) +\n    geom_histogram(fill = \"steelblue\", color = \"white\", bins = 8) +\n    labs(\n      title = paste(\"Open rate:\", tip),\n      x = \"Open rate\",\n      y = \"Broj\"\n    ) +\n    theme_minimal()\n  \n  print(p)\n}\n```\n\n::: {.cell-output-display}\n![](week-06_files/figure-docx/for-grafovi-1.png)\n:::\n\n::: {.cell-output-display}\n![](week-06_files/figure-docx/for-grafovi-2.png)\n:::\n:::\n\n\nUnutar for petlje, ggplot grafove morate eksplicitno ispisati s `print()`. Izvan petlje, R automatski ispisuje zadnji objekt, ali unutar petlje to ne radi. Ovo je čest izvor frustracije za početnike.\n\n::: {.callout-important}\n## Važna napomena\n\nFor petlje u R-u nisu pogrešne ni zastarjele, ali za većinu zadataka u tidyverse ekosustavu postoje elegantnije alternative. `group_by() |> summarise()` zamjenjuje petlje za grupirane sažetke. `across()` zamjenjuje petlje za primjenu iste operacije na više stupaca. `map()` iz paketa purrr zamjenjuje petlje za primjenu funkcije na svaki element liste ili vektora. Petlje koristite kad alternative ne postoje ili kad je petlja jasnija (što se ponekad događa).\n:::\n\n---\n\n## map(): moderna alternativa petljama {#sec-map}\n\nPaket purrr (dio tidyverse) pruža obitelj `map()` funkcija koje primjenjuju funkciju na svaki element vektora ili liste. Rezultat ovisi o varijanti map-a koju koristite.\n\n### Osnovni map()\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntipovi <- unique(nl$campaign_type)\n\n# map() vraća listu\nrezultati <- map(tipovi, function(tip) {\n  nl |>\n    filter(campaign_type == tip) |>\n    summarise(\n      tip = tip,\n      n = n(),\n      prosjek_or = round(mean(open_rate), 3)\n    )\n})\n\nbind_rows(rezultati)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  tip                n prosjek_or\n  <chr>          <int>      <dbl>\n1 special_report    17      0.259\n2 weekly_digest     12      0.289\n3 breaking_news      7      0.198\n4 sponsored          8      0.248\n5 event_promo        6      0.25 \n```\n\n\n:::\n:::\n\n\n`map()` prima vektor (ili listu) i funkciju, primjenjuje funkciju na svaki element i vraća listu rezultata. Ovo je funkcionalni ekvivalent for petlje ali u kompaktnijem obliku.\n\n### Skraćena lambda sintaksa\n\nUmjesto `function(tip) { ... }` možete koristiti skraćenu lambda sintaksu s tildom.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Skraćena lambda sintaksa: \\(x) umjesto function(x)\nrezultati <- map(tipovi, \\(tip) {\n  nl |>\n    filter(campaign_type == tip) |>\n    summarise(tip = tip, n = n(), prosjek_or = round(mean(open_rate), 3))\n})\n\nbind_rows(rezultati)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  tip                n prosjek_or\n  <chr>          <int>      <dbl>\n1 special_report    17      0.259\n2 weekly_digest     12      0.289\n3 breaking_news      7      0.198\n4 sponsored          8      0.248\n5 event_promo        6      0.25 \n```\n\n\n:::\n:::\n\n\nNotacija `\\(tip)` je R-ova nova (od verzije 4.1) skraćenica za `function(tip)`. Obje verzije rade identično, ali `\\(x)` je kraća za pisanje.\n\n### Varijante map-a\n\n`map()` uvijek vraća listu. Kad znate kakav tip rezultata očekujete, koristite specifičniju varijantu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# map_dbl() vraća numerički vektor\nprosjeci <- map_dbl(tipovi, \\(tip) {\n  nl |>\n    filter(campaign_type == tip) |>\n    pull(open_rate) |>\n    mean()\n})\n\ntibble(tip = tipovi, prosjek_or = round(prosjeci, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  tip            prosjek_or\n  <chr>               <dbl>\n1 special_report      0.259\n2 weekly_digest       0.289\n3 breaking_news       0.198\n4 sponsored           0.248\n5 event_promo         0.25 \n```\n\n\n:::\n:::\n\n\n`map_dbl()` vraća numerički (double) vektor umjesto liste. `map_chr()` vraća tekstualni vektor. `map_lgl()` vraća logički. `map_df()` vraća tibble (spaja sve rezultate). Koristite specifičnu varijantu kad god možete jer je rezultat predvidljiviji i jednostavniji za daljnji rad.\n\n### map() unutar tibble radnog toka\n\nNajelegantnija primjena `map()` je unutar tibble radnog toka, kombinirano s `nest()` i `unnest()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnl |>\n  group_by(campaign_type) |>\n  nest() |>\n  mutate(\n    n = map_dbl(data, nrow),\n    prosjek_or = map_dbl(data, \\(df) mean(df$open_rate)),\n    prosjek_ctr = map_dbl(data, \\(df) mean(df$click_rate))\n  ) |>\n  select(-data) |>\n  mutate(across(c(prosjek_or, prosjek_ctr), \\(x) round(x, 4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n# Groups:   campaign_type [5]\n  campaign_type      n prosjek_or prosjek_ctr\n  <chr>          <dbl>      <dbl>       <dbl>\n1 special_report    17      0.259      0.0519\n2 weekly_digest     12      0.289      0.029 \n3 breaking_news      7      0.198      0.0382\n4 sponsored          8      0.248      0.0223\n5 event_promo        6      0.250      0.0294\n```\n\n\n:::\n:::\n\n\nFunkcija `nest()` pakira podatke svake grupe u zasebni tibble unutar liste-stupca `data`. Zatim `map_dbl()` primjenjuje funkciju na svaki od tih ugniježđenih tibbleova. Rezultat je jedan redak po grupi s izračunatim metrikama.\n\nOvo je napredni obrazac koji ćete cijeniti kad budete radili složenije analize (na primjer, fitanje zasebnog regresijskog modela za svaku grupu u tjednu 14).\n\n---\n\n## DRY princip i organizacija skripte {#sec-dry}\n\nDRY (Don't Repeat Yourself) je programerski princip koji kaže da svaka informacija u kodu treba postojati na jednom mjestu. Kad se ponavljate, stvarate više točaka koje trebate ažurirati kad nešto promijenite, a to je recept za greške.\n\n### Primjer: parametri na jednom mjestu\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# PARAMETRI (mijenjajte ovdje, promjena se propagira svugdje)\nmin_kampanja_za_analizu <- 5\ndecimale <- 3\nboja_grafova <- \"steelblue\"\nkategorije_interesa <- c(\"weekly_digest\", \"breaking_news\", \"special_report\")\n\n# ANALIZA (koristi parametre odozgo)\nnl_filtered <- nl |>\n  filter(campaign_type %in% kategorije_interesa)\n\nnl_filtered |>\n  group_by(campaign_type) |>\n  summarise(\n    n = n(),\n    prosjek_or = round(mean(open_rate), decimale),\n    prosjek_ctr = round(mean(click_rate), decimale),\n    .groups = \"drop\"\n  ) |>\n  filter(n >= min_kampanja_za_analizu)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  campaign_type      n prosjek_or prosjek_ctr\n  <chr>          <int>      <dbl>       <dbl>\n1 breaking_news      7      0.198       0.038\n2 special_report    17      0.259       0.052\n3 weekly_digest     12      0.289       0.029\n```\n\n\n:::\n:::\n\n\nSvi ključni parametri su definirani na jednom mjestu na vrhu. Kad klijent kaže \"pokaži mi analizu samo za weekly digest i special report\", mijenjate jednu liniju i cijela analiza se ažurira. Ovo je fundamentalno drugačije od traženja i zamjenjivanja vrijednosti razbacanih po cijelom kodu.\n\n### Struktura analitičke skripte\n\nDobro organizirana skripta ima jasne sekcije. Svaka sekcija radi jednu stvar i jasno je označena.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ============================================\n# Analiza newsletter kampanja\n# Autor: Ime Prezime\n# Datum: 2025-03-29\n# Opis: Sažetak performansi email kampanja\n# ============================================\n\n# 1. PAKETI ----\nlibrary(tidyverse)\n\n# 2. PARAMETRI ----\ninput_file <- \"../resources/datasets/newsletter_campaigns.csv\"\noutput_dir <- \"../outputs/\"\nmin_n <- 5\n\n# 3. UČITAVANJE ----\nraw <- read_csv(input_file)\n\n# 4. ČIŠĆENJE ----\nclean <- raw |>\n  filter(!is.na(open_rate)) |>\n  mutate(\n    campaign_type = factor(campaign_type),\n    ocjena = case_when(\n      open_rate > 0.30 ~ \"izvrsna\",\n      open_rate > 0.20 ~ \"dobra\",\n      open_rate > 0.10 ~ \"prosjecna\",\n      .default = \"losa\"\n    )\n  )\n\n# 5. ANALIZA ----\nsazetak <- clean |>\n  group_by(campaign_type) |>\n  summarise(\n    n = n(),\n    M_or = mean(open_rate),\n    SD_or = sd(open_rate),\n    M_ctr = mean(click_rate),\n    .groups = \"drop\"\n  )\n\n# 6. VIZUALIZACIJA ----\ngraf <- ggplot(clean, aes(x = campaign_type, y = open_rate)) +\n  geom_boxplot(fill = \"steelblue\", alpha = 0.6) +\n  theme_minimal() +\n  labs(title = \"Open rate po tipu kampanje\")\n\n# 7. IZVOZ ----\nwrite_csv(sazetak, paste0(output_dir, \"sazetak_kampanja.csv\"))\nggsave(paste0(output_dir, \"boxplot_open_rate.png\"), graf, width = 8, height = 5)\n```\n:::\n\n\nKomentari s četiri crtice (`# 1. PAKETI ----`) stvaraju navigacijske oznake u Positronu (ili RStudiju) koje omogućuju brzo skakanje između sekcija. Ovo je konvencija, ne sintaktičko pravilo, ali je široko prihvaćena u R zajednici.\n\n> Vaša skripta je vaš laboratorijski dnevnik. Svaki korak je dokumentiran, svaka odluka komentirana, svaki rezultat ponovljiv. Netko (uključujući vas za šest mjeseci) mora moći pokrenuti skriptu od početka do kraja i dobiti identične rezultate.\n\n### Pomoćne funkcije na vrhu skripte\n\nKad imate funkcije koje koristite na više mjesta u analizi, definirajte ih odmah nakon učitavanja paketa. Ovo ih čini vidljivima kroz cijelu skriptu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pomoćne funkcije za newsletter analizu\nsazetak_metrike <- function(data, metrika, decimale = 3) {\n  data |>\n    summarise(\n      M = round(mean(.data[[metrika]], na.rm = TRUE), decimale),\n      Med = round(median(.data[[metrika]], na.rm = TRUE), decimale),\n      SD = round(sd(.data[[metrika]], na.rm = TRUE), decimale),\n      Min = round(min(.data[[metrika]], na.rm = TRUE), decimale),\n      Max = round(max(.data[[metrika]], na.rm = TRUE), decimale)\n    )\n}\n\nocjena_kampanje <- function(open_rate) {\n  case_when(\n    open_rate > 0.30 ~ \"izvrsna\",\n    open_rate > 0.20 ~ \"dobra\",\n    open_rate > 0.10 ~ \"prosjecna\",\n    .default = \"losa\"\n  )\n}\n\n# Korištenje pomoćnih funkcija\nnl |>\n  group_by(campaign_type) |>\n  sazetak_metrike(\"open_rate\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  campaign_type      M   Med    SD   Min   Max\n  <chr>          <dbl> <dbl> <dbl> <dbl> <dbl>\n1 breaking_news  0.198 0.195 0.055 0.115 0.281\n2 event_promo    0.25  0.23  0.086 0.161 0.408\n3 special_report 0.259 0.255 0.067 0.155 0.393\n4 sponsored      0.248 0.246 0.043 0.191 0.309\n5 weekly_digest  0.289 0.29  0.066 0.178 0.388\n```\n\n\n:::\n\n```{.r .cell-code}\nnl |>\n  mutate(ocjena = ocjena_kampanje(open_rate)) |>\n  count(ocjena, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  ocjena        n\n  <chr>     <int>\n1 dobra        25\n2 prosjecna    14\n3 izvrsna      11\n```\n\n\n:::\n:::\n\n\nDefinirajući `ocjena_kampanje()` kao funkciju, logiku rekodiranja pišete jednom. Ako se kriteriji promijene (recimo, prag za \"izvrsno\" padne na 0.28), mijenjate na jednom mjestu.\n\n---\n\n## Praktični primjer: automatizirana analiza po kampanjama {#sec-prakticni-primjer}\n\nSpojimo sve naučene koncepte u jednom praktičnom primjeru. Cilj je napisati kod koji za svaki tip kampanje generira sažetak tablica i graf, koristeći funkcije, map i DRY principe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funkcija za kompletnu analizu jednog tipa kampanje\nanaliziraj_tip <- function(data, tip) {\n  podaci <- data |> filter(campaign_type == tip)\n  \n  if (nrow(podaci) < 3) {\n    return(NULL)  # Preskoči tipove s premalo podataka\n  }\n  \n  saz <- podaci |>\n    summarise(\n      tip = tip,\n      n = n(),\n      or_M = round(mean(open_rate), 3),\n      or_SD = round(sd(open_rate), 3),\n      ctr_M = round(mean(click_rate), 4),\n      prosj_pretplatnika = round(mean(subscribers), 0),\n      prosj_rijeci = round(mean(word_count), 0)\n    )\n  \n  saz\n}\n\n# Primjena na sve tipove\nsvi_tipovi <- unique(nl$campaign_type)\n\nrezultati <- map(svi_tipovi, \\(tip) analiziraj_tip(nl, tip)) |>\n  bind_rows()\n\nrezultati |>\n  arrange(desc(or_M))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 7\n  tip                n  or_M or_SD  ctr_M prosj_pretplatnika prosj_rijeci\n  <chr>          <int> <dbl> <dbl>  <dbl>              <dbl>        <dbl>\n1 weekly_digest     12 0.289 0.066 0.029               18109          380\n2 special_report    17 0.259 0.067 0.0519              17581          486\n3 event_promo        6 0.25  0.086 0.0294              12938          210\n4 sponsored          8 0.248 0.043 0.0223              13609          204\n5 breaking_news      7 0.198 0.055 0.0382              17160          140\n```\n\n\n:::\n:::\n\n\nOvaj pristup ima nekoliko prednosti. Logika analize je enkapsulirana u jednu funkciju. Validacija (`if (nrow(podaci) < 3)`) osigurava da ne radimo besmislene izračune na premalo podataka. `map()` elegantno primjenjuje funkciju na sve tipove. Rezultat je čist tibble sortiran po open rateu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vizualizacija rezultata\nrezultati |>\n  mutate(tip = fct_reorder(tip, or_M)) |>\n  ggplot(aes(x = tip, y = or_M)) +\n  geom_col(fill = \"steelblue\") +\n  geom_errorbar(\n    aes(ymin = or_M - or_SD, ymax = or_M + or_SD),\n    width = 0.2\n  ) +\n  coord_flip() +\n  labs(\n    title = \"Prosječni open rate po tipu newsletter kampanje\",\n    subtitle = \"Stupac = prosjek, error bar = +/- 1 SD\",\n    x = NULL,\n    y = \"Open rate\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](week-06_files/figure-docx/prakticni-primjer-graf-1.png)\n:::\n:::\n\n\nError barovi (crte pogreške) prikazuju jednu standardnu devijaciju iznad i ispod prosjeka, dajući vizualni uvid u varijabilnost unutar svake kategorije. Breaking news kampanje imaju viši prosječni open rate ali i veću varijabilnost, dok su sponsored kampanje konzistentno niže.\n\n---\n\n::: {.callout-note}\n## Podsjetnik\n\nU prvom dijelu naučili smo pisati vlastite funkcije, koristiti uvjetne naredbe, for petlje i map() iz paketa purrr. U ovom dijelu primjenjujemo te vještine na realne radne tokove: rad s više datoteka, debugging, Quarto izvještaji i kompletna automatizirana analiza.\n:::\n\n## Rad s više datoteka {#sec-vise-datoteka}\n\nU praksi, podaci rijetko dolaze u jednoj datoteci. Možda imate zasebne CSV datoteke za svaki mjesec, za svaku kampanju ili za svaki izvor podataka. Umjesto ručnog učitavanja svake datoteke, možete automatizirati taj proces koristeći koncepte koje smo upravo naučili.\n\n### Pronalaženje datoteka\n\nFunkcija `list.files()` pronalazi datoteke u direktoriju po zadanom uzorku.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Popis svih CSV datoteka u datasets direktoriju\ncsv_datoteke <- list.files(\n  path = \"../resources/datasets/\",\n  pattern = \"\\\\.csv$\",\n  full.names = TRUE\n)\n\ncsv_datoteke\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"../resources/datasets/ab_test_headlines.csv\"   \n [2] \"../resources/datasets/article_engagement.csv\"  \n [3] \"../resources/datasets/instagram_ab_test.csv\"   \n [4] \"../resources/datasets/media_habits_raw.csv\"    \n [5] \"../resources/datasets/media_population.csv\"    \n [6] \"../resources/datasets/media_trust.csv\"         \n [7] \"../resources/datasets/newsletter_campaign.csv\" \n [8] \"../resources/datasets/newsletter_campaigns.csv\"\n [9] \"../resources/datasets/social_media_survey.csv\" \n[10] \"../resources/datasets/social_posts.csv\"        \n[11] \"../resources/datasets/tiktok_usage.csv\"        \n```\n\n\n:::\n:::\n\n\nArgument `pattern = \"\\\\.csv$\"` koristi regularni izraz za pronalaženje datoteka koje završavaju s .csv. `full.names = TRUE` vraća kompletne putanje (ne samo imena datoteka), što je bitno jer ih trebamo za učitavanje.\n\n### Učitavanje više datoteka odjednom\n\nKombinirajmo `list.files()`, `map()` i `bind_rows()` za učitavanje i spajanje svih CSV datoteka u jednom koraku.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Učitaj sve CSV datoteke i spoji ih\nsvi_podaci <- csv_datoteke |>\n  map(\\(f) read_csv(f, show_col_types = FALSE)) |>\n  bind_rows()\n```\n:::\n\n\nOvo je moćan obrazac. `map()` primjenjuje `read_csv()` na svaku putanju, vraćajući listu tibbleova. `bind_rows()` ih vertikalno spaja u jedan veliki tibble. Ako datoteke imaju iste stupce, rezultat je jednostavna konkatenacija. Ako se stupci razlikuju, `bind_rows()` popunjava nedostajuće s NA.\n\n### Dodavanje informacije o izvoru\n\nČesto želite znati iz koje datoteke dolazi koji redak. Funkcija `set_names()` pomaže.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Učitaj sve datoteke i dodaj stupac s imenom datoteke\nsvi_podaci <- csv_datoteke |>\n  set_names() |>\n  map(\\(f) read_csv(f, show_col_types = FALSE)) |>\n  bind_rows(.id = \"izvor\")\n```\n:::\n\n\nArgument `.id = \"izvor\"` u `bind_rows()` kreira novi stupac `izvor` koji sadrži ime elementa liste (u ovom slučaju putanju datoteke). Ovo je korisno za praćenje porijekla podataka.\n\n::: {.callout-tip}\n## Praktični savjet\n\nObrazac `list.files() |> map(read_csv) |> bind_rows()` je jedan od najkorisnijih obrazaca u cijelom R radnom toku. Naučite ga napamet. Koristit ćete ga svaki put kad dobijete podatke razdijeljene u više datoteka (mjesečni izvještaji, odvojene ankete, logovi po danima).\n:::\n\n---\n\n## Debugging: pronalaženje i ispravljanje grešaka {#sec-debugging}\n\nGreške su neizbježan dio programiranja. Pitanje nije hoćete li naletjeti na grešku, nego koliko ćete brzo identificirati i ispraviti problem. R daje poruke o greškama koje su ponekad jasne, a ponekad kriptične. Evo strategija za sustavno traženje problema.\n\n### Čitanje poruka o greškama\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tipična greška: objekt ne postoji\nnl |>\n  filter(kampanja_tip == \"weekly_digest\")\n# Error: object 'kampanja_tip' not found\n\n# Čitamo: R ne može naći objekt 'kampanja_tip'\n# Rješenje: provjerimo imena stupaca\nnames(nl)\n# Ah, stupac se zove 'campaign_type', ne 'kampanja_tip'\n```\n:::\n\n\nPoruka \"object not found\" gotovo uvijek znači jednu od tri stvari: pogrešno ime (tipfeler), objekt još nije kreiran (izvršili ste kod izvan redoslijeda) ili je objekt u drugom okruženju (na primjer, kreiran unutar funkcije ali ne i izvan nje).\n\n### Strategija: izoliraj problem\n\nKad imate dugački pipeline koji ne radi, razbijte ga na dijelove i pokrenite svaki zasebno.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Umjesto pokretanja cijelog pipelinea odjednom:\n# nl |> filter(...) |> mutate(...) |> group_by(...) |> summarise(...)\n\n# Pokrenite korak po korak:\nkorak1 <- nl |> filter(campaign_type == \"weekly_digest\")\nkorak1  # Provjerite: izgleda li ovo kako očekujete?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 13\n   campaign_id campaign_type subject_style   day_sent    send_hour subscribers\n   <chr>       <chr>         <chr>           <chr>           <dbl>       <dbl>\n 1 NL-002      weekly_digest hitno           petak              11       14266\n 2 NL-007      weekly_digest upitni          srijeda            13       23450\n 3 NL-009      weekly_digest personalizirani subota             11       12444\n 4 NL-011      weekly_digest personalizirani utorak             11       23941\n 5 NL-016      weekly_digest informativni    cetvrtak           15       12188\n 6 NL-022      weekly_digest hitno           utorak             18       12768\n 7 NL-026      weekly_digest brojke          utorak              7       12035\n 8 NL-032      weekly_digest personalizirani utorak             18       18310\n 9 NL-034      weekly_digest brojke          cetvrtak           20       24014\n10 NL-035      weekly_digest hitno           ponedjeljak         7       19975\n11 NL-037      weekly_digest personalizirani nedjelja           18       20070\n12 NL-038      weekly_digest informativni    nedjelja           14       23842\n# ℹ 7 more variables: open_rate <dbl>, click_rate <dbl>,\n#   unsubscribe_rate <dbl>, word_count <dbl>, n_links <dbl>, has_image <lgl>,\n#   revenue <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\nkorak2 <- korak1 |> mutate(or_pct = open_rate * 100)\nkorak2 |> select(campaign_id, open_rate, or_pct) |> head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  campaign_id open_rate or_pct\n  <chr>           <dbl>  <dbl>\n1 NL-002          0.270   27.0\n2 NL-007          0.288   28.8\n3 NL-009          0.283   28.3\n```\n\n\n:::\n\n```{.r .cell-code}\n# OK, ovo radi. Idemo dalje...\n\nkorak3 <- korak2 |>\n  summarise(\n    n = n(),\n    prosjek = round(mean(or_pct), 1)\n  )\nkorak3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n      n prosjek\n  <int>   <dbl>\n1    12    28.9\n```\n\n\n:::\n:::\n\n\nPohranjivanjem svakog koraka u zasebni objekt, možete točno identificirati na kojem koraku nastaje problem. Kad pronađete i ispravite grešku, spojite korake natrag u pipeline.\n\n### print() i glimpse() kao dijagnostika\n\nUnutar funkcija i petlji, dodajte privremene `print()` naredbe da vidite što se događa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Debugging s print naredbama\nanaliziraj_debug <- function(data, tip) {\n  podaci <- data |> filter(campaign_type == tip)\n  cat(\"Tip:\", tip, \"| Redova:\", nrow(podaci), \"\\n\")  # Debug ispis\n  \n  if (nrow(podaci) == 0) {\n    cat(\"UPOZORENJE: nema podataka za tip\", tip, \"\\n\")\n    return(NULL)\n  }\n  \n  podaci |>\n    summarise(\n      tip = tip,\n      n = n(),\n      or_M = round(mean(open_rate), 3)\n    )\n}\n\n# Testirajte s poznatim i nepoznatim tipom\nanaliziraj_debug(nl, \"weekly_digest\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTip: weekly_digest | Redova: 12 \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  tip               n  or_M\n  <chr>         <int> <dbl>\n1 weekly_digest    12 0.289\n```\n\n\n:::\n\n```{.r .cell-code}\nanaliziraj_debug(nl, \"nepostojeci_tip\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTip: nepostojeci_tip | Redova: 0 \nUPOZORENJE: nema podataka za tip nepostojeci_tip \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\nKad ste riješili problem, uklonite debug ispise. Ostavljanje privremenih `cat()` i `print()` naredbi u gotovom kodu je loša praksa jer zatrpava konzolu nepotrebnim ispisom.\n\n### Česte greške i rješenja\n\nPogledajmo najčešće greške koje ćete susresti i kako ih riješiti.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. \"could not find function\" -> paket nije učitan\nsummarise(nl, n = n())\n# Rješenje: library(tidyverse) na početku\n\n# 2. \"unexpected symbol\" -> nedostaje zarez, operator ili zagrada\nnl |>\n  mutate(x = open_rate y = click_rate)  # Nedostaje zarez\n# Rješenje: mutate(x = open_rate, y = click_rate)\n\n# 3. \"+ ggplot\" umjesto \"|> ggplot\"\nnl |>\n  filter(open_rate > 0.2) +  # Krivo: + umjesto |>\n  ggplot(aes(x = open_rate))\n# Rješenje: koristiti |> do ggplot(), pa + za slojeve\n\n# 4. \"object of type 'closure' is not subsettable\"\nmean[1]  # mean je funkcija, ne vektor\n# Rješenje: provjerite jeste li slučajno prepisali ime varijable imenom funkcije\n```\n:::\n\n\n> Svaki iskusni programer bio je početnik koji je satima tražio zarez koji nedostaje. Debugging nije znak neznanja, nego sastavni dio posla. Razlika između početnika i iskusnog korisnika nije u tome što iskusni ne griješe, nego u tome da imaju sustavan pristup traženju grešaka.\n\n---\n\n## Quarto: integracija koda, teksta i rezultata {#sec-quarto}\n\nDo sada ste pisali R kod u skriptama (.R datoteke) koje proizvode tablice i grafove u konzoli. Quarto dokumenti (.qmd datoteke) omogućuju nešto moćnije: integraciju teksta, koda i rezultata u jedan dokument koji se renderira u HTML, PDF ili Word.\n\nZapravo, svako predavanje na ovom kolegiju je Quarto dokument. Tekst koji čitate, kod koji vidite i grafovi koji se prikazuju nastaju iz jedne .qmd datoteke.\n\n### Struktura Quarto dokumenta\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Quarto dokument ima tri dijela:\n\n# 1. YAML zaglavlje (između --- oznaka)\n# ---\n# title: \"Analiza newsletter kampanja\"\n# author: \"Ime Prezime\"\n# date: today\n# format: html\n# ---\n\n# 2. Tekst u Markdown formatu\n# ## Uvod\n# Ova analiza ispituje performanse naših newsletter kampanja...\n\n# 3. R code chunkovi (između ``` oznaka)\n# ```{r}\n# library(tidyverse)\n# nl <- read_csv(\"newsletter_campaigns.csv\")\n# ```\n```\n:::\n\n\nKad pokrenete `quarto render`, Quarto izvršava R kod, hvata rezultate (tablice, grafove, ispis) i umeće ih u dokument zajedno s tekstom. Rezultat je profesionalan izvještaj u kojem su analiza i prezentacija neodvojivi.\n\n### Chunk opcije za kontrolu ispisa\n\nOpcije unutar code chunkova kontroliraju što se prikazuje u dokumentu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# echo: true   -> prikaži kod u dokumentu\n# echo: false  -> sakrij kod, prikaži samo rezultat\n# eval: true   -> izvrši kod\n# eval: false  -> ne izvršavaj (samo prikaži kod)\n# message: false -> sakrij poruke paketa\n# warning: false -> sakrij upozorenja\n# fig-width: 8  -> širina grafa u inčima\n# fig-height: 5 -> visina grafa u inčima\n\n# Za izvještaj klijentu: echo: false (ne želi vidjeti kod)\n# Za kolegicu analitičarku: echo: true (želi vidjeti kako ste to napravili)\n```\n:::\n\n\nOva fleksibilnost je ključna. Isti Quarto dokument možete renderirati s `echo: true` za interni tim (koji želi vidjeti kod) i s `echo: false` za klijenta (koji želi samo rezultate). Mijenjate jednu opciju u YAML zaglavlju i dobivate potpuno drugačiji dokument.\n\n### Inline R kod\n\nOsim code chunkova, R vrijednosti možete umetnuti direktno u tekst.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_kampanja <- nrow(nl)\nprosjek_or <- round(mean(nl$open_rate) * 100, 1)\nnajbolji_tip <- nl |>\n  group_by(campaign_type) |>\n  summarise(or = mean(open_rate), .groups = \"drop\") |>\n  slice_max(or) |>\n  pull(campaign_type)\n```\n:::\n\n\nU Quarto dokumentu biste napisali tekst poput: \"Analizirali smo 50 kampanja. Prosječni open rate je 25.5%. Najbolji rezultat ima tip weekly_digest.\"\n\nKad se dokument renderira, R vrijednosti se automatski umeću u tekst. Ako se podaci promijene, tekst se automatski ažurira. Nikad više ne morate ručno ažurirati brojke u izvještaju.\n\n### Quarto vs R skripta: kad koristiti što\n\nR skripta (.R) je pravi izbor kad je cilj izračun, transformacija ili generiranje outputa (tablice, grafovi, datoteke). Skripta je brza za izvršavanje i laka za debugging.\n\nQuarto dokument (.qmd) je pravi izbor kad je cilj komunikacija rezultata. Izvještaj za klijenta, akademski rad, interna prezentacija, kolegijalni materijal. Quarto integrira narativ i rezultate u jedinstven dokument.\n\nU praksi, mnogi analitičari koriste oboje: skripta za teški posao (čišćenje, modeliranje), Quarto za prezentaciju rezultata. Skripta generira čiste podatke i grafove, Quarto ih ugrađuje u priču.\n\n---\n\n## Funkcionali za složenije radne tokove {#sec-funkcionali}\n\nVratimo se purrr paketu i pogledajmo naprednije obrasce koji su korisni u praksi.\n\n### walk(): map() bez povratne vrijednosti\n\nPonekad želite izvršiti nešto za svaki element (na primjer, spremiti graf) ali ne trebate povratnu vrijednost. `walk()` je varijanta `map()` koja izvršava funkciju ali tiho odbacuje rezultat.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Spremi zaseban graf za svaki tip kampanje\ntipovi <- unique(nl$campaign_type)\n\nwalk(tipovi, \\(tip) {\n  p <- nl |>\n    filter(campaign_type == tip) |>\n    ggplot(aes(x = open_rate)) +\n    geom_histogram(fill = \"steelblue\", color = \"white\", bins = 8) +\n    labs(title = paste(\"Open rate:\", tip)) +\n    theme_minimal()\n  \n  ggsave(paste0(\"graf_\", tip, \".png\"), p, width = 7, height = 4)\n})\n```\n:::\n\n\n`walk()` je idiomatski R način za petlje koje proizvode popratne efekte (side effects) poput spremanja datoteka, ispisa na konzolu ili slanja emailova. Za razliku od `map()`, ne zatrpava konzolu listom NULL vrijednosti.\n\n### map2(): paralelna iteracija preko dva vektora\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Dva vektora: metrike i njihovi naslovi\nmetrike <- c(\"open_rate\", \"click_rate\")\nnaslovi <- c(\"Open rate kampanja\", \"Click rate kampanja\")\n\n# map2 iterira paralelno: prvi element s prvim, drugi s drugim\nrezultati <- map2(metrike, naslovi, \\(metrika, naslov) {\n  nl |>\n    sazetak_metrike(metrika) |>\n    mutate(metrika = naslov)\n})\n\nbind_rows(rezultati)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n      M   Med    SD   Min   Max metrika            \n  <dbl> <dbl> <dbl> <dbl> <dbl> <chr>              \n1 0.255 0.252 0.068 0.115 0.408 Open rate kampanja \n2 0.037 0.037 0.019 0.005 0.086 Click rate kampanja\n```\n\n\n:::\n:::\n\n\n`map2()` prima dva vektora i iterira paralelno. Na prvoj iteraciji koristi `metrike[1]` i `naslovi[1]`, na drugoj `metrike[2]` i `naslovi[2]`, i tako dalje. Ovo je korisno kad imate parove ulaznih podataka.\n\n### imap(): iteracija s indeksom\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# imap daje i element i njegovo ime/indeks\nnl |>\n  group_by(campaign_type) |>\n  group_split() |>\n  set_names(unique(nl$campaign_type) |> sort()) |>\n  imap(\\(podaci, ime) {\n    tibble(\n      tip = ime,\n      n = nrow(podaci),\n      or_M = round(mean(podaci$open_rate), 3)\n    )\n  }) |>\n  bind_rows()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  tip                n  or_M\n  <chr>          <int> <dbl>\n1 breaking_news      7 0.198\n2 event_promo        6 0.25 \n3 special_report    17 0.259\n4 sponsored          8 0.248\n5 weekly_digest     12 0.289\n```\n\n\n:::\n:::\n\n\n`imap()` je varijanta `map()` koja automatski proslijeđuje i element i njegovo ime (ili indeks). Korisna je kad trebate znati koji element trenutno obrađujete, na primjer za imenovanje rezultata ili za dijagnostiku.\n\n### possibly(): zaštita od grešaka\n\nKad primjenjujete funkciju na mnogo elemenata, jedna greška može srušiti cijeli pipeline. `possibly()` omotava funkciju u zaštitni sloj koji hvata greške i vraća default vrijednost umjesto da prekida izvršavanje.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funkcija koja ponekad pada\nopasna_funkcija <- function(tip) {\n  podaci <- nl |> filter(campaign_type == tip)\n  if (nrow(podaci) < 3) stop(\"Premalo podataka!\")\n  mean(podaci$open_rate)\n}\n\n# Bez zaštite: jedna greška ruši sve\n# map_dbl(c(\"weekly_digest\", \"nepostojeci\"), opasna_funkcija)  # Error!\n\n# S zaštitom: greška vraća NA, ostali rezultati ostaju\nsigurna_funkcija <- possibly(opasna_funkcija, otherwise = NA_real_)\n\nmap_dbl(c(\"weekly_digest\", \"nepostojeci\", \"breaking_news\"), sigurna_funkcija)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2886833        NA 0.1978286\n```\n\n\n:::\n:::\n\n\n`possibly(f, otherwise = NA)` kreira novu funkciju koja radi isto kao `f`, ali umjesto da baci grešku, vraća `otherwise` vrijednost. Ovo je neprocjenjivo kad učitavate 50 datoteka i jedna je korumpirana, ili kad analizirate 20 grupa i jedna ima nedovoljno podataka.\n\n---\n\n## Kompletna analiza: automatizirani izvještaj o kampanjama {#sec-kompletna}\n\nSpojimo sve iz ovog predavanja u jednu koherentnu analizu. Cilj je napisati kod koji bi mogao biti tijelo Quarto izvještaja o performansama newsletter kampanja.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\n# PARAMETRI\nmin_kampanja <- 3\ndecimale <- 3\nfokus_metrike <- c(\"open_rate\", \"click_rate\", \"unsubscribe_rate\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# POMOĆNE FUNKCIJE\nsazetak_tipa <- function(data, tip, dec = 3) {\n  d <- data |> filter(campaign_type == tip)\n  \n  if (nrow(d) < min_kampanja) return(NULL)\n  \n  tibble(\n    tip = tip,\n    n = nrow(d),\n    or_M = round(mean(d$open_rate), dec),\n    or_SD = round(sd(d$open_rate), dec),\n    ctr_M = round(mean(d$click_rate), dec + 1),\n    unsub_M = round(mean(d$unsubscribe_rate), dec + 2),\n    prosj_rijeci = round(mean(d$word_count), 0),\n    udio_sa_slikom = round(mean(d$has_image), 2)\n  )\n}\n\ngraf_usporedba <- function(data, metrika, naslov, boja = \"steelblue\") {\n  data |>\n    ggplot(aes(x = fct_reorder(campaign_type, .data[[metrika]]),\n               y = .data[[metrika]])) +\n    geom_boxplot(fill = boja, alpha = 0.6) +\n    coord_flip() +\n    labs(title = naslov, x = NULL, y = metrika) +\n    theme_minimal()\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ANALIZA\ntipovi <- unique(nl$campaign_type)\n\n# Sažetak za sve tipove (s automatskim preskakanjem malih grupa)\ntablica_sazetka <- map(tipovi, \\(t) sazetak_tipa(nl, t, decimale)) |>\n  bind_rows() |>\n  arrange(desc(or_M))\n\ntablica_sazetka\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 8\n  tip                n  or_M or_SD  ctr_M unsub_M prosj_rijeci udio_sa_slikom\n  <chr>          <int> <dbl> <dbl>  <dbl>   <dbl>        <dbl>          <dbl>\n1 weekly_digest     12 0.289 0.066 0.029  0.00331          380           0.67\n2 special_report    17 0.259 0.067 0.0519 0.00279          486           0.76\n3 event_promo        6 0.25  0.086 0.0294 0.00207          210           1   \n4 sponsored          8 0.248 0.043 0.0223 0.00645          204           0.75\n5 breaking_news      7 0.198 0.055 0.0382 0.00405          140           0.71\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Analiza po stilu naslova (unutar svake kampanje)\nnl |>\n  group_by(campaign_type, subject_style) |>\n  summarise(\n    n = n(),\n    or_M = round(mean(open_rate), 3),\n    .groups = \"drop\"\n  ) |>\n  filter(n >= 2) |>\n  pivot_wider(\n    names_from = subject_style,\n    values_from = or_M\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 7\n   campaign_type      n informativni personalizirani upitni brojke  hitno\n   <chr>          <int>        <dbl>           <dbl>  <dbl>  <dbl>  <dbl>\n 1 breaking_news      5        0.182          NA     NA     NA     NA    \n 2 event_promo        2       NA               0.285 NA     NA     NA    \n 3 event_promo        3       NA              NA      0.245 NA     NA    \n 4 special_report     2       NA               0.242 NA      0.237 NA    \n 5 special_report     4       NA              NA     NA     NA      0.329\n 6 special_report     6        0.2            NA     NA     NA     NA    \n 7 special_report     3       NA              NA      0.31  NA     NA    \n 8 sponsored          3       NA              NA     NA      0.252 NA    \n 9 sponsored          2       NA              NA     NA     NA      0.224\n10 weekly_digest      2        0.21           NA     NA      0.254 NA    \n11 weekly_digest      3       NA              NA     NA     NA      0.312\n12 weekly_digest      4       NA               0.328 NA     NA     NA    \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# VIZUALIZACIJA\ng1 <- graf_usporedba(nl, \"open_rate\", \"Open rate po tipu\")\ng2 <- graf_usporedba(nl, \"click_rate\", \"Click rate po tipu\", boja = \"#2a9d8f\")\n\ng1 + g2 +\n  plot_annotation(\n    title = \"Performanse newsletter kampanja\",\n    subtitle = \"Usporedba open rate i click rate po tipu kampanje\",\n    caption = paste(\"N =\", nrow(nl), \"kampanja\")\n  )\n```\n\n::: {.cell-output-display}\n![](week-06_files/figure-docx/kompletna-vizualizacija-1.png)\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Odnos open rate i click rate\nnl |>\n  ggplot(aes(x = open_rate, y = click_rate, color = campaign_type, size = subscribers)) +\n  geom_point(alpha = 0.6) +\n  geom_smooth(method = \"lm\", se = FALSE, linewidth = 0.8) +\n  scale_size_continuous(labels = scales::label_comma()) +\n  labs(\n    title = \"Kampanje s višim open rateom tendiraju imati viši click rate\",\n    subtitle = \"Veličina točke proporcionalna broju pretplatnika\",\n    x = \"Open rate\",\n    y = \"Click rate\",\n    color = \"Tip kampanje\",\n    size = \"Pretplatnici\"\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](week-06_files/figure-docx/kompletna-scatter-1.png)\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Kada slati newsletter?\nnl |>\n  mutate(\n    dio_dana = case_when(\n      send_hour < 10 ~ \"jutro (6-9)\",\n      send_hour < 14 ~ \"prijepodne (10-13)\",\n      send_hour < 18 ~ \"poslijepodne (14-17)\",\n      .default = \"navečer (18+)\"\n    )\n  ) |>\n  group_by(dio_dana) |>\n  summarise(\n    n = n(),\n    or_M = round(mean(open_rate), 3),\n    ctr_M = round(mean(click_rate), 4),\n    .groups = \"drop\"\n  ) |>\n  arrange(desc(or_M))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  dio_dana                 n  or_M  ctr_M\n  <chr>                <int> <dbl>  <dbl>\n1 navečer (18+)            9 0.277 0.0388\n2 poslijepodne (14-17)    15 0.26  0.04  \n3 prijepodne (10-13)      10 0.245 0.0307\n4 jutro (6-9)             16 0.243 0.0373\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# KLJUČNI NALAZ: koji faktori predviđaju open rate?\nnl |>\n  summarise(\n    kor_rijeci_or = round(cor(word_count, open_rate), 3),\n    kor_linkovi_ctr = round(cor(n_links, click_rate), 3),\n    kor_pretplatnici_or = round(cor(subscribers, open_rate), 3)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  kor_rijeci_or kor_linkovi_ctr kor_pretplatnici_or\n          <dbl>           <dbl>               <dbl>\n1         0.127          -0.239              -0.075\n```\n\n\n:::\n:::\n\n\nAnaliza otkriva nekoliko nalaza. Breaking news i kampanje s hitnim stilom naslova imaju najviši open rate, ali uz veću varijabilnost. Click rate ne prati savršeno open rate, što sugerira da su čimbenici koji navode ljude da otvore email (naslov, hitnost) različiti od onih koji ih navode da kliknu na sadržaj (relevantnost, format). Korelacija između broja riječi i open ratea govori o preferiranom formatu, dok veličina baze pretplatnika sama po sebi ne predviđa bolji angažman.\n\nCijela ova analiza, od učitavanja podataka do gotovih grafova i nalaza, koristi principe koje smo naučili ovaj tjedan. Parametri su na jednom mjestu. Pomoćne funkcije enkapsuliraju ponovljivu logiku. map() automatizira iteraciju. Vizualizacija prati principe iz prošlog tjedna. I sve je napisano tako da se može pokrenuti ponovno s novim podacima bez ikakvih promjena u kodu (osim, eventualno, putanje do datoteke).\n\n> Kad pišete analizu, zamislite da ju netko pokreće prvi put, bez ikakvog konteksta. Može li taj netko razumjeti što kod radi, zašto, i kako interpretirati rezultate? Ako da, napisali ste dobru analizu.\n\n---\n\n::: {.callout-important}\n## Ključni zaključci\n\n1. Funkcije su alat za izbjegavanje ponavljanja koda. Pravilo tri: ako ste kopirali isti kod tri puta, pretvorite ga u funkciju. Default vrijednosti argumenata čine funkcije fleksibilnima.\n\n2. Klasični `if`/`else` radi s jednom vrijednošću (za skripte i funkcije). `if_else()` i `case_when()` su vektorizirani (za `mutate()`). Ne miješajte ih.\n\n3. Validacija ulaza u funkcijama sprečava tihe greške. Koristite `warning()` za upozorenja i `return()` za rano izlaženje.\n\n4. `for` petlje ponavljaju kod za svaki element. Unutar petlje, grafove morate ispisati s `print()`. Za većinu zadataka postoje elegantnije alternative.\n\n5. `map()` iz paketa purrr je moderna alternativa petljama. `map_dbl()`, `map_chr()` i `map_lgl()` vraćaju specifične tipove. `walk()` je za popratne efekte (spremanje datoteka).\n\n6. `map2()` iterira paralelno preko dva vektora. `imap()` daje i element i njegovo ime. `possibly()` štiti od grešaka unutar iteracije.\n\n7. Obrazac `list.files() |> map(read_csv) |> bind_rows()` učitava i spaja više datoteka u jednom koraku.\n\n8. Debugging zahtijeva sustavan pristup: čitanje poruka, izolacija problema (korak po korak), privremeni `cat()`/`print()` ispisi.\n\n9. DRY princip: parametri na jednom mjestu, logika u funkcijama, struktura skripte u jasnim sekcijama.\n\n10. Quarto dokumenti integriraju tekst, kod i rezultate. Koristite ih za izvještaje, radove i prezentacije. R skripte su za teški izračun, Quarto za komunikaciju.\n\n11. Chunk opcije (`echo`, `eval`, `message`, `warning`, `fig-width`) kontroliraju što se prikazuje u renderiranom dokumentu. `echo: false` sakriva kod za klijente.\n\n12. Cilj ponovljive analize: netko može pokrenuti vaš kod od početka do kraja s novim podacima i dobiti ažurirane rezultate bez ručnih promjena.\n:::\n\n---\n\n::: {.callout-warning}\n## Priprema za sljedeći tjedan\n\nSljedeći tjedan ulazimo u **uvod u vjerojatnost**: što je vjerojatnost, kako ju računamo, binomna i normalna distribucija. Ovo je konceptualni temelj za sve statističke testove koje ćemo raditi u drugom dijelu kolegija.\n\nZa pripremu:\n\n1. Napišite vlastitu funkciju koja prima tibble i ime kategoričke varijable te vraća tibble s brojem i udjelom (%) svake kategorije. Testirajte je na datasetu `newsletter_campaigns.csv`.\n2. Koristeći `map()`, generirajte sažetak open ratea za svaki dan u tjednu (stupac `day_sent`). Spojite rezultate u jedan tibble.\n3. Napišite kratki Quarto dokument (.qmd) koji učitava podatke, prikazuje jedan graf i jednu tablicu, s popratnim tekstom. Renderirajte ga u HTML.\n4. Pročitajte poglavlje 9 iz Navarro (Learning Statistics with R) o vjerojatnosti. Fokusirajte se na intuiciju, ne na formule.\n:::\n\n---\n\n## Dodatno čitanje\n\n**Obavezno**\n\nWickham, H. & Grolemund, G. (2023). *R for Data Science* (2nd edition), Chapters 26, 27 i 29. Besplatno dostupno na [r4ds.hadley.nz](https://r4ds.hadley.nz). Poglavlje 26 pokriva funkcije, poglavlje 27 iteraciju s purrr, poglavlje 29 Quarto dokumente.\n\nNavarro, D. (2018). *Learning Statistics with R*, Chapter 8. Besplatno dostupno na [learningstatisticswithr.com](https://learningstatisticswithr.com/lsr-0.6.pdf). Osnove programiranja u R-u.\n\n**Preporučeno**\n\nWickham, H. (2019). *Advanced R* (2nd edition), Chapters 6 i 9. Besplatno dostupno na [adv-r.hadley.nz](https://adv-r.hadley.nz). Poglavlje 6 detaljno pokriva funkcije, poglavlje 9 funkcionalno programiranje (map i prijatelji).\n\nQuarto dokumentacija. Besplatno dostupno na [quarto.org](https://quarto.org). Kompletna dokumentacija za Quarto sustav sa tutorijalima za HTML, PDF i Word dokumente.\n\nBryan, J. & Hester, J. *What They Forgot to Teach You About R*. Besplatno dostupno na [rstats.wtf](https://rstats.wtf). Praktični savjeti o organizaciji projekata, debugging-u i radnim tokovima koji se ne uče u udžbenicima statistike.\n\n---\n\n## Pojmovnik\n\n| Pojam | Objašnjenje |\n|---|---|\n| Funkcija | Objekt koji prima argumente, izvršava operacije i vraća rezultat. Definira se s `function()`. |\n| Argument | Ulazni podatak funkcije. Navodi se unutar zagrada pri definiciji i pozivu. |\n| Default vrijednost | Podrazumijevana vrijednost argumenta. Definira se s `=` u listi argumenata. |\n| Povratna vrijednost | Rezultat funkcije. Zadnji izraz u tijelu, ili eksplicitno s `return()`. |\n| `return()` | Eksplicitno vraća vrijednost i izlazi iz funkcije. Korisno za ranu validaciju. |\n| `if`/`else` | Uvjetna naredba za kontrolu toka. Radi s jednom vrijednošću (nije vektorizirana). |\n| `if_else()` | Vektorizirana uvjetna funkcija za `mutate()`. Radi na cijelom stupcu. |\n| `case_when()` | Vektorizirana funkcija za složeno rekodiranje s više uvjeta. |\n| `for` petlja | Ponavlja blok koda za svaki element u skupu. Sintaksa: `for (x in skup) { ... }`. |\n| `map()` | purrr funkcija koja primjenjuje funkciju na svaki element i vraća listu. |\n| `map_dbl()` | Varijanta `map()` koja vraća numerički vektor. |\n| `map_chr()` | Varijanta `map()` koja vraća tekstualni vektor. |\n| `map_lgl()` | Varijanta `map()` koja vraća logički vektor. |\n| `map2()` | purrr funkcija za paralelnu iteraciju preko dva vektora. |\n| `imap()` | purrr funkcija koja proslijeđuje i element i njegovo ime/indeks. |\n| `walk()` | Varijanta `map()` za popratne efekte (spremanje datoteka). Ne vraća rezultat. |\n| `possibly()` | purrr funkcija koja omotava funkciju u zaštitni sloj. Greška vraća default vrijednost umjesto prekida. |\n| purrr | Paket iz tidyverse za funkcijsko programiranje. |\n| `nest()` | tidyr funkcija koja pakira podatke grupe u ugniježđeni tibble. |\n| `bind_rows()` | Vertikalno spaja listu tibbleova u jedan. |\n| `list.files()` | Base R funkcija za pronalaženje datoteka u direktoriju po uzorku. |\n| `set_names()` | Dodjeljuje imena elementima vektora ili liste. |\n| DRY | Don't Repeat Yourself. Princip da informacija postoji na jednom mjestu u kodu. |\n| Lambda funkcija | Anonimna funkcija. Piše se kao `\\(x) x + 1` ili `function(x) x + 1`. |\n| `.data[[var]]` | Pristup stupcu po imenu pohranjenom u varijabli. Za tidyverse funkcije. |\n| `cat()` | Ispis teksta u konzolu. Bez navodnih oznaka i indeksa. |\n| `warning()` | Ispis upozorenja. Ne zaustavlja program. |\n| `stop()` | Ispis greške i zaustavljanje programa. Za kritične probleme. |\n| Validacija ulaza | Provjera ispravnosti argumenata prije izvršavanja. Sprečava tihe greške. |\n| Skripta (.R) | R datoteka s nizom naredbi. Za izračune i transformacije. |\n| Quarto dokument (.qmd) | Datoteka koja integrira tekst, kod i rezultate. Za izvještaje i komunikaciju. |\n| Chunk opcije | Postavke R code chunka u Quarto dokumentu (echo, eval, message, warning, fig-width). |\n| Inline R kod | R izraz umetnut u tekst Quarto dokumenta. Automatski se evaluira pri renderiranju. |\n| Debugging | Proces pronalaženja i ispravljanja grešaka u kodu. |\n| Side effect | Popratni efekt funkcije (ispis, spremanje datoteke) koji nije povratna vrijednost. |\n| Ponovljiva analiza | Analiza napisana tako da se može pokrenuti od početka do kraja s novim podacima bez ručnih promjena. |\n",
    "supporting": [
      "week-06_files\\figure-docx"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}