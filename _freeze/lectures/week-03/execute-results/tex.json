{
  "hash": "dce791c07196509162842aec83d371ac",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tjedan 3: Rad s podacima u tidyverse\"\nsubtitle: \"Od sirovih podataka do analizi spremnog dataseta\"\ndate: 2025-03-08\ncategories: [dplyr, tidyr, manipulacija podataka, čišćenje podataka]\ndraft: false\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(janitor)\n```\n:::\n\n\n::: {.callout-note}\n## Ishodi učenja\n\nNakon ovog predavanja moći ćete\n\n1. Objasniti zašto je čišćenje i transformacija podataka najvažniji (i najdugotrajniji) korak u svakoj analizi.\n2. Koristiti `clean_names()` za standardizaciju imena stupaca i prepoznati zašto je to važno za ponovljivost.\n3. Koristiti `filter()` za odabir redova po jednom ili više uvjeta, uključujući kombinacije logičkih operatora i rad s nedostajućim vrijednostima.\n4. Koristiti `select()` za odabir, preimenovanje i preuređivanje stupaca, uključujući pomoćne funkcije poput `starts_with()`, `ends_with()` i `contains()`.\n5. Koristiti `mutate()` za kreiranje novih varijabli, transformaciju postojećih i rekodiranje vrijednosti pomoću `case_when()` i `if_else()`.\n6. Koristiti `arrange()` za sortiranje podataka po jednom ili više stupaca u uzlaznom i silaznom redoslijedu.\n7. Kombinirati dplyr glagole u pipeline koristeći pipe operator za složene transformacije podataka.\n8. Prepoznati tipične probleme u sirovim podacima (nekonzistentno kodiranje, mješoviti tipovi, nedostajuće vrijednosti) i primijeniti odgovarajuće strategije čišćenja.\n:::\n\n## Prljava tajna analize podataka\n\nPostoji jedna stvar o kojoj vam udžbenici statistike rijetko govore. Otvorite bilo koji udžbenik i vidjet ćete poglavlje o t-testu, poglavlje o regresiji, poglavlje o ANOVA-i. Sve lijepo i uredno. Ali nitko vam ne kaže da ćete 80% vremena u bilo kojoj analizi provesti na nečemu što se ne pojavljuje ni u jednom od tih poglavlja: na čišćenju i pripremi podataka.\n\nOvo nije pretjerivanje. Stvarni podaci su gotovo uvijek neuredni. Anketa prikupljena putem Google Formsa dolazi s imenima stupaca poput \"Koliko često pratite vijesti na društvenim mrežama? (odaberite jedan odgovor)\". Ispitanici u polje za spol upisuju \"Ženski\", \"ženski\", \"Ž\", \"female\" i \"Zensko\", a sve to treba biti ista kategorija. Stupac koji bi trebao sadržavati brojeve sadrži i tekst poput \"ne gledam\" ili prazne ćelije. Neki ispitanici imaju 19 godina, a jedan ima 199 jer mu je prst skliznuo na tipkovnici.\n\nSve ovo morate riješiti prije nego što možete izračunati ijedan prosjek ili napraviti ijedno testiranje hipoteza. I upravo zato je ovaj tjedan posvećen manipulaciji podacima. Naučit ćemo pet temeljnih funkcija iz paketa dplyr (`filter()`, `select()`, `mutate()`, `summarise()`, `group_by()`) plus alate za čišćenje i preoblikovanje iz paketa tidyr i janitor. Ove funkcije, spojene pipe operatorom u elegantne pipeline, čine okosnicu svake analize podataka u R-u.\n\nNavarro u knjizi (poglavlja 4 i 7) pokriva sličan teren, ali u base R sintaksi. Mi ćemo koristiti tidyverse pristup koji je čitljiviji i konzistentniji. Kad ste jednom naučili logiku dplyr glagola, ista logika se primjenjuje na svaki dataset, svaki problem, svaku analizu.\n\n---\n\n## Naši podaci: anketa o medijskim navikama studenata {#sec-podaci}\n\nNa ovom predavanju koristit ćemo simulirani dataset koji oponaša ono što biste zaista dobili kad biste proveli online anketu među studentima. Dataset je namjerno neuredan jer želimo vježbati čišćenje podataka na realističnom primjeru.\n\nUčitajmo podatke i pogledajmo s čime se suočavamo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw <- read_csv(\"../resources/datasets/media_habits_raw.csv\")\nglimpse(raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 250\nColumns: 17\n$ `ID respondenta`                    <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,~\n$ Timestamp                           <dttm> 2025-03-28 17:05:00, 2025-04-20 2~\n$ Dob                                 <dbl> 20, 27, 27, 18, 25, 26, 28, 26, 22~\n$ Spol                                <chr> \"ženski\", \"Muški\", \"muški\", \"femal~\n$ Grad                                <chr> \"Zagreb\", \"Zadar\", \"Zagreb\", \"Spli~\n$ `Godina studija`                    <chr> \"2\", \"3\", \"1\", \"1\", \"2\", \"2.\", \"2\"~\n$ `TV (min/dan)`                      <chr> \"0\", \"0\", \"65\", NA, NA, \"91\", \"91\"~\n$ `Portali (min/dan)`                 <dbl> 40, 20, 0, 11, 32, 25, 81, 28, 37,~\n$ `Društvene mreže (min/dan)`         <dbl> 59, 101, 177, 71, 161, 155, 114, 1~\n$ `Radio (min/dan)`                   <dbl> 49, NA, 0, NA, 26, NA, 0, 0, 17, 0~\n$ `Podcast (min/dan)`                 <dbl> 89, 0, 49, 0, 0, NA, NA, 31, 0, 19~\n$ `Povjerenje TV (1-10)`              <dbl> 2, 3, 4, 5, 5, 4, 3, 6, 6, 7, 2, 7~\n$ `Povjerenje portali (1-10)`         <dbl> 6, 5, 6, 6, 3, 7, 7, 1, 7, 5, 6, 5~\n$ `Povjerenje društvene mreže (1-10)` <dbl> 4, 3, 1, 4, 4, 7, 2, 3, 4, 6, 1, 2~\n$ `Broj platformi`                    <dbl> 9, 5, 7, 6, 5, 2, 1, 8, 5, 7, 6, 6~\n$ `Koje platforme koristi`            <chr> \"Snapchat, WhatsApp, Facebook\", \"F~\n$ `Koliko često prati vijesti`        <chr> \"više puta dnevno\", \"nekoliko puta~\n```\n\n\n:::\n:::\n\n\nVeć na prvi pogled vidimo nekoliko problema. Imena stupaca sadrže razmake, zagrade i dijakritičke znakove, što otežava rad u R-u. Stupci poput `Spol` imaju nekonzistentne vrijednosti. Stupac `TV (min/dan)` sadrži i brojeve i tekst (\"ne gledam\") i prazne ćelije, pa ga je R učitao kao tekst umjesto broja.\n\nPogledajmo prvih nekoliko redova detaljnije.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw |>\n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 17\n   `ID respondenta` Timestamp             Dob Spol   Grad     `Godina studija`\n              <dbl> <dttm>              <dbl> <chr>  <chr>    <chr>           \n 1                1 2025-03-28 17:05:00    20 ženski Zagreb   2               \n 2                2 2025-04-20 21:11:00    27 Muški  Zadar    3               \n 3                3 2025-04-18 14:48:00    27 muški  Zagreb   1               \n 4                4 2025-03-28 12:54:00    18 female Split    1               \n 5                5 2025-03-21 18:06:00    25 Ženski Zagreb   2               \n 6                6 2025-04-14 20:26:00    26 M      Zagreb   2.              \n 7                7 2025-04-22 15:48:00    28 m      Zagreb   2               \n 8                8 2025-03-04 19:04:00    26 ženski Karlovac 2               \n 9                9 2025-03-12 12:17:00    22 female Split    2               \n10               10 2025-03-19 18:17:00    21 ž      Osijek   1               \n# i 11 more variables: `TV (min/dan)` <chr>, `Portali (min/dan)` <dbl>,\n#   `Društvene mreže (min/dan)` <dbl>, `Radio (min/dan)` <dbl>,\n#   `Podcast (min/dan)` <dbl>, `Povjerenje TV (1-10)` <dbl>,\n#   `Povjerenje portali (1-10)` <dbl>,\n#   `Povjerenje društvene mreže (1-10)` <dbl>, `Broj platformi` <dbl>,\n#   `Koje platforme koristi` <chr>, `Koliko često prati vijesti` <chr>\n```\n\n\n:::\n:::\n\n\nOvo je tipičan izgled sirovih podataka iz ankete. Prije bilo kakve analize, moramo napraviti čišćenje. Krenimo redom.\n\n---\n\n## Korak nula: čišćenje imena stupaca {#sec-clean-names}\n\nPrva stvar koju radimo sa svakim novim datasetom je standardizacija imena stupaca. Imena poput `TV (min/dan)` i `Povjerenje društvene mreže (1-10)` su problematična jer sadrže razmake, zagrade i specijalne znakove. Kad ih želite koristiti u kodu, morate ih stavljati u obrnute navodnike: `` `TV (min/dan)` ``. To je neugodno, nečitljivo i podložno greškama.\n\nPaket janitor ima funkciju `clean_names()` koja automatski pretvara sva imena u snake_case format: mala slova, razmaci zamijenjeni podvlakama, specijalni znakovi uklonjeni.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw <- raw |>\n  clean_names()\n\nnames(raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"id_respondenta\"                  \"timestamp\"                      \n [3] \"dob\"                             \"spol\"                           \n [5] \"grad\"                            \"godina_studija\"                 \n [7] \"tv_min_dan\"                      \"portali_min_dan\"                \n [9] \"drustvene_mreze_min_dan\"         \"radio_min_dan\"                  \n[11] \"podcast_min_dan\"                 \"povjerenje_tv_1_10\"             \n[13] \"povjerenje_portali_1_10\"         \"povjerenje_drustvene_mreze_1_10\"\n[15] \"broj_platformi\"                  \"koje_platforme_koristi\"         \n[17] \"koliko_cesto_prati_vijesti\"     \n```\n\n\n:::\n:::\n\n\nUsporedite ova imena s originalnima. Umjesto `Povjerenje društvene mreže (1-10)` sada imamo `povjerenje_drustvene_mreze_1_10`. Duže jest, ali potpuno funkcionalno u R kodu bez ikakvih navodnika ili zagrada. Ovo je mala investicija koja štedi mnogo frustracije.\n\n::: {.callout-tip}\n## Praktični savjet\n\nNavikajte se da `clean_names()` bude prva stvar koju pozovete nakon `read_csv()`. Možete to čak staviti u isti pipeline: `raw <- read_csv(\"datoteka.csv\") |> clean_names()`. Ovo je toliko standardna praksa da mnogi R korisnici to rade automatski za svaki dataset, čak i kad su imena stupaca već uredna. Bolje spriječiti nego liječiti.\n:::\n\nSad kad imamo čista imena, možemo krenuti s pravim poslom. Pogledajmo strukturu nakon čišćenja.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 250\nColumns: 17\n$ id_respondenta                  <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,~\n$ timestamp                       <dttm> 2025-03-28 17:05:00, 2025-04-20 21:11~\n$ dob                             <dbl> 20, 27, 27, 18, 25, 26, 28, 26, 22, 21~\n$ spol                            <chr> \"ženski\", \"Muški\", \"muški\", \"female\", ~\n$ grad                            <chr> \"Zagreb\", \"Zadar\", \"Zagreb\", \"Split\", ~\n$ godina_studija                  <chr> \"2\", \"3\", \"1\", \"1\", \"2\", \"2.\", \"2\", \"2~\n$ tv_min_dan                      <chr> \"0\", \"0\", \"65\", NA, NA, \"91\", \"91\", \"0~\n$ portali_min_dan                 <dbl> 40, 20, 0, 11, 32, 25, 81, 28, 37, 5, ~\n$ drustvene_mreze_min_dan         <dbl> 59, 101, 177, 71, 161, 155, 114, 119, ~\n$ radio_min_dan                   <dbl> 49, NA, 0, NA, 26, NA, 0, 0, 17, 0, 0,~\n$ podcast_min_dan                 <dbl> 89, 0, 49, 0, 0, NA, NA, 31, 0, 19, 0,~\n$ povjerenje_tv_1_10              <dbl> 2, 3, 4, 5, 5, 4, 3, 6, 6, 7, 2, 7, 7,~\n$ povjerenje_portali_1_10         <dbl> 6, 5, 6, 6, 3, 7, 7, 1, 7, 5, 6, 5, 5,~\n$ povjerenje_drustvene_mreze_1_10 <dbl> 4, 3, 1, 4, 4, 7, 2, 3, 4, 6, 1, 2, 3,~\n$ broj_platformi                  <dbl> 9, 5, 7, 6, 5, 2, 1, 8, 5, 7, 6, 6, 2,~\n$ koje_platforme_koristi          <chr> \"Snapchat, WhatsApp, Facebook\", \"Faceb~\n$ koliko_cesto_prati_vijesti      <chr> \"više puta dnevno\", \"nekoliko puta tje~\n```\n\n\n:::\n:::\n\n\n---\n\n## filter(): odabir redova po uvjetu {#sec-filter}\n\nFunkcija `filter()` je dplyr glagol za odabir redova koji zadovoljavaju jedan ili više uvjeta. Rezultat je tibble koji sadrži samo retke za koje su svi uvjeti TRUE. Redovi za koje je uvjet FALSE ili NA se odbacuju.\n\n### Osnovni uvjeti\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Samo ispitanici iz Zagreba\nraw |>\n  filter(grad == \"Zagreb\") |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n\n```{.r .cell-code}\n# Ispitanici mlađi od 21\nraw |>\n  filter(dob < 21) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 17\n  id_respondenta timestamp             dob spol  grad  godina_studija tv_min_dan\n           <dbl> <dttm>              <dbl> <chr> <chr> <chr>          <chr>     \n1              1 2025-03-28 17:05:00    20 žens~ Zagr~ 2              0         \n2              4 2025-03-28 12:54:00    18 fema~ Split 1              <NA>      \n3             13 2025-03-25 15:16:00    20 muški Zagr~ 1              0         \n4             14 2025-04-20 11:09:00    20 Žens~ Zagr~ 2              0         \n5             16 2025-04-07 18:06:00    19 muški Split 1              0         \n# i 10 more variables: portali_min_dan <dbl>, drustvene_mreze_min_dan <dbl>,\n#   radio_min_dan <dbl>, podcast_min_dan <dbl>, povjerenje_tv_1_10 <dbl>,\n#   povjerenje_portali_1_10 <dbl>, povjerenje_drustvene_mreze_1_10 <dbl>,\n#   broj_platformi <dbl>, koje_platforme_koristi <chr>,\n#   koliko_cesto_prati_vijesti <chr>\n```\n\n\n:::\n:::\n\n\nSvaki poziv `filter()` zapravo evaluira logički izraz za svaki redak. Za prvi primjer, R prolazi kroz svaki od 250 redova i provjerava je li vrijednost u stupcu `grad` jednaka \"Zagreb\". Retci za koje je odgovor TRUE ostaju, ostali nestaju.\n\n### Kombiniranje uvjeta\n\nSnaga `filter()` dolazi do izražaja kad kombinirate više uvjeta. Unutar jednog `filter()` poziva, uvjeti odvojeni zarezom automatski se kombiniraju s I operatorom (`&`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ispitanici iz Zagreba mlađi od 22\n# Zarez između uvjeta je ekvivalentan &\nraw |>\n  filter(grad == \"Zagreb\", dob < 22) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 41\n```\n\n\n:::\n\n```{.r .cell-code}\n# Isto kao:\nraw |>\n  filter(grad == \"Zagreb\" & dob < 22) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 41\n```\n\n\n:::\n:::\n\n\nOba pristupa daju identičan rezultat. Zarez je kraći za pisanje, `&` je eksplicitniji. Koristite što vam je čitljivije.\n\nZa ILI uvjete, morate eksplicitno koristiti `|` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ispitanici iz Zagreba ILI Splita\nraw |>\n  filter(grad == \"Zagreb\" | grad == \"Split\") |>\n  count(grad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  grad       n\n  <chr>  <int>\n1 Split     44\n2 Zagreb   100\n```\n\n\n:::\n\n```{.r .cell-code}\n# Elegantnije s %in%\nraw |>\n  filter(grad %in% c(\"Zagreb\", \"Split\", \"Rijeka\")) |>\n  count(grad, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  grad       n\n  <chr>  <int>\n1 Zagreb   100\n2 Split     44\n3 Rijeka    18\n```\n\n\n:::\n:::\n\n\nOperator `%in%` smo upoznali prošli tjedan. U kontekstu `filter()` je izuzetno koristan jer zamjenjuje dugačke nizove ILI uvjeta jednim kompaktnim izrazom. Kad imate više od dvije kategorije, uvijek koristite `%in%`.\n\n### Filtriranje numeričkih raspona\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ispitanici koji koriste društvene mreže između 60 i 180 minuta dnevno\nraw |>\n  filter(drustvene_mreze_min_dan >= 60, drustvene_mreze_min_dan <= 180) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 202\n```\n\n\n:::\n\n```{.r .cell-code}\n# Alternativa s between()\nraw |>\n  filter(between(drustvene_mreze_min_dan, 60, 180)) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 202\n```\n\n\n:::\n:::\n\n\nFunkcija `between(x, left, right)` je kratica za `x >= left & x <= right`. Oba pristupa daju isti rezultat, ali `between()` je čitljiviji kad filtrirate po rasponu.\n\n### Filtriranje teksta\n\nZa tekstualne stupce, osim točnog podudaranja (`==`) i pripadnosti skupu (`%in%`), koristimo funkciju `str_detect()` iz paketa stringr (dio tidyverse) za pretraživanje po uzorku.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ispitanici čije platforme uključuju \"Instagram\" (bilo gdje u tekstu)\nraw |>\n  filter(str_detect(koje_platforme_koristi, \"Instagram\")) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 39\n```\n\n\n:::\n\n```{.r .cell-code}\n# Ispitanici koji prate vijesti barem jednom dnevno\nraw |>\n  filter(str_detect(koliko_cesto_prati_vijesti, \"dnevno\")) |>\n  count(koliko_cesto_prati_vijesti)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  koliko_cesto_prati_vijesti     n\n  <chr>                      <int>\n1 jednom dnevno                 60\n2 više puta dnevno              81\n```\n\n\n:::\n:::\n\n\nFunkcija `str_detect()` vraća TRUE ako tekstualni uzorak postoji bilo gdje u vrijednosti. Ovo je mnogo fleksibilnije od `==` jer ne zahtijeva točno podudaranje. Na primjer, `str_detect(x, \"dnevno\")` hvata i \"više puta dnevno\" i \"jednom dnevno\".\n\n### filter() i nedostajuće vrijednosti\n\nVažno svojstvo `filter()` je da **automatski odbacuje retke s NA u uvjetu**. Ovo je uglavnom poželjno ponašanje, ali morate biti svjesni da se događa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Koliko redova imamo ukupno?\nnrow(raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 250\n```\n\n\n:::\n\n```{.r .cell-code}\n# Koliko ima NA u stupcu radio_min_dan?\nsum(is.na(raw$radio_min_dan))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32\n```\n\n\n:::\n\n```{.r .cell-code}\n# filter s numeričkim uvjetom na stupcu s NA\nraw |>\n  filter(radio_min_dan > 0) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 92\n```\n\n\n:::\n:::\n\n\nRezultat ne uključuje retke s NA u stupcu `radio_min_dan`. Ako želite eksplicitno zadržati retke s NA, morate to navesti.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Zadrži retke gdje je radio > 0 ILI je NA\nraw |>\n  filter(radio_min_dan > 0 | is.na(radio_min_dan)) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 124\n```\n\n\n:::\n\n```{.r .cell-code}\n# Zadrži SAMO retke s NA\nraw |>\n  filter(is.na(radio_min_dan)) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32\n```\n\n\n:::\n\n```{.r .cell-code}\n# Izbaci retke s NA (zadrži samo kompletne)\nraw |>\n  filter(!is.na(radio_min_dan)) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 218\n```\n\n\n:::\n:::\n\n\nKombinacija `filter(!is.na(stupac))` je način da zadržite samo retke s poznatim vrijednostima u tom stupcu. Alternativno, funkcija `drop_na()` iz paketa tidyr uklanja retke koji imaju NA u bilo kojem stupcu (ili u specificiranim stupcima).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ukloni retke s NA u specifičnom stupcu\nraw |>\n  drop_na(radio_min_dan) |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 218\n```\n\n\n:::\n\n```{.r .cell-code}\n# Ukloni retke s NA u BILO KOJEM stupcu (agresivno!)\nraw |>\n  drop_na() |>\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 149\n```\n\n\n:::\n:::\n\n\nPrimijetite drastičnu razliku. Kad koristimo `drop_na()` bez argumenata, gubimo mnogo redova jer se uklanjaju svi retci koji imaju NA u ijednom stupcu. U praksi, `drop_na()` bez argumenata se rijetko koristi jer je previše agresivan. Bolje je ciljano raditi s NA u stupcima koji vas zapravo zanimaju.\n\n::: {.callout-important}\n## Važna napomena\n\nSvaki put kad koristite `filter()` ili `drop_na()`, dokumentirajte koliko redova ste izgubili i zašto. Ako ste od 250 ispitanika zadržali samo 150, to je informacija koju morate navesti u metodološkom dijelu rada. Čitatelj mora znati na koliko se opažanja vaši rezultati temelje i zašto su neka isključena.\n:::\n\n---\n\n## select(): odabir i preimenovanje stupaca {#sec-select}\n\nDok `filter()` radi s redovima, `select()` radi sa stupcima. Koristi se za tri svrhe: odabir stupaca koji vam trebaju, uklanjanje stupaca koji vam ne trebaju i preimenovanje stupaca.\n\n### Odabir po imenu\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Odabir specifičnih stupaca\nraw |>\n  select(id_respondenta, dob, spol, grad) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 4\n  id_respondenta   dob spol   grad  \n           <dbl> <dbl> <chr>  <chr> \n1              1    20 ženski Zagreb\n2              2    27 Muški  Zadar \n3              3    27 muški  Zagreb\n4              4    18 female Split \n5              5    25 Ženski Zagreb\n```\n\n\n:::\n\n```{.r .cell-code}\n# Odabir raspona stupaca (od do)\nraw |>\n  select(id_respondenta:godina_studija) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 6\n  id_respondenta timestamp             dob spol   grad   godina_studija\n           <dbl> <dttm>              <dbl> <chr>  <chr>  <chr>         \n1              1 2025-03-28 17:05:00    20 ženski Zagreb 2             \n2              2 2025-04-20 21:11:00    27 Muški  Zadar  3             \n3              3 2025-04-18 14:48:00    27 muški  Zagreb 1             \n4              4 2025-03-28 12:54:00    18 female Split  1             \n5              5 2025-03-21 18:06:00    25 Ženski Zagreb 2             \n```\n\n\n:::\n:::\n\n\nStupce navodite po imenu, bez navodnika. Operator `:` bira sve stupce između dva navedena, uključujući oba krajnja. Ovo je praktično kad su relevantni stupci jedan do drugoga u datasetu.\n\n### Uklanjanje stupaca\n\nMinus ispred imena stupca znači \"sve osim ovoga\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sve osim timestampa i ID-a\nraw |>\n  select(-timestamp, -id_respondenta) |>\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"dob\"                             \"spol\"                           \n [3] \"grad\"                            \"godina_studija\"                 \n [5] \"tv_min_dan\"                      \"portali_min_dan\"                \n [7] \"drustvene_mreze_min_dan\"         \"radio_min_dan\"                  \n [9] \"podcast_min_dan\"                 \"povjerenje_tv_1_10\"             \n[11] \"povjerenje_portali_1_10\"         \"povjerenje_drustvene_mreze_1_10\"\n[13] \"broj_platformi\"                  \"koje_platforme_koristi\"         \n[15] \"koliko_cesto_prati_vijesti\"     \n```\n\n\n:::\n\n```{.r .cell-code}\n# Uklanjanje raspona\nraw |>\n  select(-(povjerenje_tv_1_10:povjerenje_drustvene_mreze_1_10)) |>\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"id_respondenta\"             \"timestamp\"                 \n [3] \"dob\"                        \"spol\"                      \n [5] \"grad\"                       \"godina_studija\"            \n [7] \"tv_min_dan\"                 \"portali_min_dan\"           \n [9] \"drustvene_mreze_min_dan\"    \"radio_min_dan\"             \n[11] \"podcast_min_dan\"            \"broj_platformi\"            \n[13] \"koje_platforme_koristi\"     \"koliko_cesto_prati_vijesti\"\n```\n\n\n:::\n:::\n\n\n### Pomoćne funkcije za odabir\n\nKad imate mnogo stupaca, ručno nabrajanje postaje nepraktično. dplyr nudi pomoćne funkcije za pametni odabir.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Stupci čije ime počinje s \"povjerenje\"\nraw |>\n  select(starts_with(\"povjerenje\")) |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  povjerenje_tv_1_10 povjerenje_portali_1_10 povjerenje_drustvene_mreze_1_10\n               <dbl>                   <dbl>                           <dbl>\n1                  2                       6                               4\n2                  3                       5                               3\n3                  4                       6                               1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Stupci čije ime završava s \"dan\"\nraw |>\n  select(ends_with(\"dan\")) |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 5\n  tv_min_dan portali_min_dan drustvene_mreze_min_dan radio_min_dan\n  <chr>                <dbl>                   <dbl>         <dbl>\n1 0                       40                      59            49\n2 0                       20                     101            NA\n3 65                       0                     177             0\n# i 1 more variable: podcast_min_dan <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Stupci čije ime sadrži \"min\"\nraw |>\n  select(contains(\"min\")) |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 5\n  tv_min_dan portali_min_dan drustvene_mreze_min_dan radio_min_dan\n  <chr>                <dbl>                   <dbl>         <dbl>\n1 0                       40                      59            49\n2 0                       20                     101            NA\n3 65                       0                     177             0\n# i 1 more variable: podcast_min_dan <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Samo numerički stupci\nraw |>\n  select(where(is.numeric)) |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 10\n  id_respondenta   dob portali_min_dan drustvene_mreze_min_dan radio_min_dan\n           <dbl> <dbl>           <dbl>                   <dbl>         <dbl>\n1              1    20              40                      59            49\n2              2    27              20                     101            NA\n3              3    27               0                     177             0\n# i 5 more variables: podcast_min_dan <dbl>, povjerenje_tv_1_10 <dbl>,\n#   povjerenje_portali_1_10 <dbl>, povjerenje_drustvene_mreze_1_10 <dbl>,\n#   broj_platformi <dbl>\n```\n\n\n:::\n:::\n\n\nFunkcija `starts_with()` bira stupce čije ime počinje zadanim tekstom. `ends_with()` bira po završetku. `contains()` traži tekst bilo gdje u imenu. `where()` prima funkciju za provjeru tipa i bira stupce koji zadovoljavaju taj uvjet. Ove funkcije postaju neprocjenjive kad radite s datasetima koji imaju 50 ili 100 stupaca (što nije neuobičajeno u anketnim istraživanjima).\n\n### Preimenovanje stupaca\n\nUnutar `select()` možete preimenovati stupac sintaksom `novo_ime = staro_ime`. Ili koristite zasebnu funkciju `rename()` koja preimenu stupce ali zadrži sve ostale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Preimenovanje unutar select (odabire SAMO navedene stupce)\nraw |>\n  select(\n    id = id_respondenta,\n    dob,\n    spol,\n    sm_minuta = drustvene_mreze_min_dan\n  ) |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 4\n     id   dob spol   sm_minuta\n  <dbl> <dbl> <chr>      <dbl>\n1     1    20 ženski        59\n2     2    27 Muški        101\n3     3    27 muški        177\n```\n\n\n:::\n\n```{.r .cell-code}\n# rename() mijenja imena ali zadržava sve stupce\nraw |>\n  rename(\n    id = id_respondenta,\n    sm_minuta = drustvene_mreze_min_dan\n  ) |>\n  names()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"id\"                              \"timestamp\"                      \n [3] \"dob\"                             \"spol\"                           \n [5] \"grad\"                            \"godina_studija\"                 \n [7] \"tv_min_dan\"                      \"portali_min_dan\"                \n [9] \"sm_minuta\"                       \"radio_min_dan\"                  \n[11] \"podcast_min_dan\"                 \"povjerenje_tv_1_10\"             \n[13] \"povjerenje_portali_1_10\"         \"povjerenje_drustvene_mreze_1_10\"\n[15] \"broj_platformi\"                  \"koje_platforme_koristi\"         \n[17] \"koliko_cesto_prati_vijesti\"     \n```\n\n\n:::\n:::\n\n\nRazlika je važna. `select()` s preimenovanjem zadržava samo stupce koje ste naveli. `rename()` zadržava sve stupce i samo mijenja imena onih koje ste specificirali. U praksi, `rename()` je sigurniji izbor kad želite samo promijeniti ime jednog ili dva stupca bez gubitka ostalih.\n\n### Preuređivanje stupaca\n\nFunkcija `relocate()` premješta stupce na drugu poziciju u datasetu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Premjesti grad na početak (odmah nakon ID-a)\nraw |>\n  relocate(grad, .after = id_respondenta) |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 17\n  id_respondenta grad  timestamp             dob spol  godina_studija tv_min_dan\n           <dbl> <chr> <dttm>              <dbl> <chr> <chr>          <chr>     \n1              1 Zagr~ 2025-03-28 17:05:00    20 žens~ 2              0         \n2              2 Zadar 2025-04-20 21:11:00    27 Muški 3              0         \n3              3 Zagr~ 2025-04-18 14:48:00    27 muški 1              65        \n# i 10 more variables: portali_min_dan <dbl>, drustvene_mreze_min_dan <dbl>,\n#   radio_min_dan <dbl>, podcast_min_dan <dbl>, povjerenje_tv_1_10 <dbl>,\n#   povjerenje_portali_1_10 <dbl>, povjerenje_drustvene_mreze_1_10 <dbl>,\n#   broj_platformi <dbl>, koje_platforme_koristi <chr>,\n#   koliko_cesto_prati_vijesti <chr>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Premjesti sve numeričke stupce na kraj\nraw |>\n  relocate(where(is.numeric), .after = last_col()) |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 17\n  timestamp           spol   grad   godina_studija tv_min_dan\n  <dttm>              <chr>  <chr>  <chr>          <chr>     \n1 2025-03-28 17:05:00 ženski Zagreb 2              0         \n2 2025-04-20 21:11:00 Muški  Zadar  3              0         \n3 2025-04-18 14:48:00 muški  Zagreb 1              65        \n# i 12 more variables: koje_platforme_koristi <chr>,\n#   koliko_cesto_prati_vijesti <chr>, id_respondenta <dbl>, dob <dbl>,\n#   portali_min_dan <dbl>, drustvene_mreze_min_dan <dbl>, radio_min_dan <dbl>,\n#   podcast_min_dan <dbl>, povjerenje_tv_1_10 <dbl>,\n#   povjerenje_portali_1_10 <dbl>, povjerenje_drustvene_mreze_1_10 <dbl>,\n#   broj_platformi <dbl>\n```\n\n\n:::\n:::\n\n\n`relocate()` ne dodaje niti uklanja stupce, samo ih premješta. Ovo je korisno za organizaciju dataseta kad želite da relevantni stupci budu jedni do drugih.\n\n---\n\n## mutate(): kreiranje i transformacija varijabli {#sec-mutate}\n\nFunkcija `mutate()` je najsvestraniji dplyr glagol. Služi za kreiranje novih stupaca na temelju postojećih, transformaciju postojećih stupaca i rekodiranje vrijednosti. Rezultat je tibble s istim brojem redova ali potencijalno novim ili izmijenjenim stupcima.\n\n### Kreiranje novih varijabli\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ukupno dnevno korištenje medija (portal + društvene mreže)\nraw |>\n  mutate(\n    ukupno_digital = portali_min_dan + drustvene_mreze_min_dan\n  ) |>\n  select(id_respondenta, portali_min_dan, drustvene_mreze_min_dan, ukupno_digital) |>\n  head(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 4\n  id_respondenta portali_min_dan drustvene_mreze_min_dan ukupno_digital\n           <dbl>           <dbl>                   <dbl>          <dbl>\n1              1              40                      59             99\n2              2              20                     101            121\n3              3               0                     177            177\n4              4              11                      71             82\n5              5              32                     161            193\n6              6              25                     155            180\n7              7              81                     114            195\n8              8              28                     119            147\n```\n\n\n:::\n:::\n\n\n`mutate()` evaluira izraz na desnoj strani znaka jednakosti za svaki redak i rezultat pohranjuje u novi stupac nazvan imenom na lijevoj strani. Kao i kod vektoriziranih operacija, R automatski primjenjuje operaciju redak po redak.\n\nMožete kreirati više stupaca u jednom `mutate()` pozivu, i kasniji stupci mogu koristiti ranije definirane.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw |>\n  mutate(\n    ukupno_digital = portali_min_dan + drustvene_mreze_min_dan,\n    ukupno_sati = ukupno_digital / 60,\n    iznad_2_sata = ukupno_sati > 2\n  ) |>\n  select(id_respondenta, ukupno_digital, ukupno_sati, iznad_2_sata) |>\n  head(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 4\n  id_respondenta ukupno_digital ukupno_sati iznad_2_sata\n           <dbl>          <dbl>       <dbl> <lgl>       \n1              1             99        1.65 FALSE       \n2              2            121        2.02 TRUE        \n3              3            177        2.95 TRUE        \n4              4             82        1.37 FALSE       \n5              5            193        3.22 TRUE        \n6              6            180        3    TRUE        \n7              7            195        3.25 TRUE        \n8              8            147        2.45 TRUE        \n```\n\n\n:::\n:::\n\n\nPrimijetite da smo u istom `mutate()` pozivu najprije izračunali `ukupno_digital`, zatim ga koristili za izračun `ukupno_sati`, a onda `ukupno_sati` za logički stupac `iznad_2_sata`. Ova mogućnost referiranja na upravo kreirane stupce čini `mutate()` izuzetno moćnim.\n\n### Transformacija postojećih stupaca\n\n`mutate()` može i prepisati postojeći stupac.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Zaokruži portal minute na desetice (prepisuje stupac)\nraw |>\n  mutate(\n    portali_min_dan = round(portali_min_dan, -1)\n  ) |>\n  select(id_respondenta, portali_min_dan) |>\n  head(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 2\n  id_respondenta portali_min_dan\n           <dbl>           <dbl>\n1              1              40\n2              2              20\n3              3               0\n4              4              10\n5              5              30\n6              6              20\n7              7              80\n8              8              30\n```\n\n\n:::\n:::\n\n\nKad date mutate stupcu isto ime kao postojeći stupac, novi vrijednosti zamjenjuju stare. Ovo je korisno za čišćenje podataka (na primjer, pretvorbu teksta u mala slova), ali budite oprezni jer originalne vrijednosti nestaju. Dobra praksa je raditi transformacije na kopiji dataseta, ne na originalu.\n\n### Čišćenje stupca spol: str_to_lower() i case_when() {#sec-case-when}\n\nPogledajmo koliko je neuredan stupac `spol` u našim podacima.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw |>\n  count(spol, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 2\n   spol       n\n   <chr>  <int>\n 1 Muški     48\n 2 Ženski    45\n 3 muški     42\n 4 ženski    31\n 5 Ž         16\n 6 male      14\n 7 M         11\n 8 Musko     11\n 9 ž         10\n10 m          9\n11 Zensko     7\n12 female     6\n```\n\n\n:::\n:::\n\n\nImamo dvanaestak varijanti istih dviju kategorija. \"Ženski\", \"ženski\", \"Ž\", \"ž\", \"Zensko\", \"female\" bi sve trebalo biti jedna kategorija. Ovo je klasičan problem u anketnim podacima i jedan od najčešćih razloga za čišćenje.\n\nFunkcija `case_when()` je najfleksibilniji alat za rekodiranje. Radi kao niz IF-THEN pravila: za svaki redak, R provjerava uvjete redom i dodjeljuje vrijednost prvog uvjeta koji je ispunjen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw <- raw |>\n  mutate(\n    spol_clean = case_when(\n      str_to_lower(spol) %in% c(\"ženski\", \"ž\", \"zensko\", \"female\") ~ \"ženski\",\n      str_to_lower(spol) %in% c(\"muški\", \"m\", \"musko\", \"male\") ~ \"muški\",\n      .default = \"ostalo\"\n    )\n  )\n\nraw |>\n  count(spol_clean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  spol_clean     n\n  <chr>      <int>\n1 muški        135\n2 ženski       115\n```\n\n\n:::\n:::\n\n\nRaščlanimo ovaj kod. Funkcija `str_to_lower()` pretvara tekst u mala slova, čime eliminiramo razliku između \"Ženski\" i \"ženski\". Zatim `%in%` provjerava pripada li vrijednost jednom od navedenih oblika. Ako da, dodjeljuje standardizirani oblik. Argument `.default` hvata sve što ne odgovara nijednom uvjetu.\n\nRezultat je čist stupac `spol_clean` s tri konzistentne kategorije umjesto dvanaest neujednačenih varijanti.\n\n::: {.callout-tip}\n## Praktični savjet\n\nKad čistite tekstualne podatke, uvijek najprije pretvorite u mala slova pomoću `str_to_lower()`. Ovo odmah eliminira najčešći izvor nekonzistentnosti (razliku u kapitalizaciji) i smanjuje broj slučajeva koje morate pokriti u `case_when()`. Redoslijed je važan: najprije `str_to_lower()`, pa onda provjere.\n:::\n\n### Rekodiranje numeričkih varijabli u kategorije\n\nČest zadatak u komunikologiji je pretvaranje kontinuirane varijable u kategorije. Na primjer, umjesto točne dobi, želimo dobne skupine.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw <- raw |>\n  mutate(\n    dobna_skupina = case_when(\n      dob < 20 ~ \"18-19\",\n      dob < 22 ~ \"20-21\",\n      dob < 24 ~ \"22-23\",\n      dob >= 24 ~ \"24+\"\n    )\n  )\n\nraw |>\n  count(dobna_skupina)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 2\n  dobna_skupina     n\n  <chr>         <int>\n1 18-19            73\n2 20-21            61\n3 22-23            47\n4 24+              69\n```\n\n\n:::\n:::\n\n\nRedoslijed uvjeta u `case_when()` je bitan. R provjerava uvjete odozgo prema dolje i dodjeljuje vrijednost prvog ispunjenog uvjeta. Ako osoba ima 19 godina, prvi uvjet (`dob < 20`) je TRUE i dodjeljuje se \"18-19\". R ne provjerava preostale uvjete. Zato uvjete postavljamo od najspecifičnijeg prema najopćenitijem.\n\n### if_else(): binarno rekodiranje\n\nZa jednostavne da/ne situacije, `if_else()` je kraći od `case_when()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw <- raw |>\n  mutate(\n    visoko_koristenje_sm = if_else(drustvene_mreze_min_dan > 120, \"visoko\", \"nisko/umjereno\"),\n    prati_vijesti_cesto = if_else(\n      koliko_cesto_prati_vijesti %in% c(\"više puta dnevno\", \"jednom dnevno\"),\n      TRUE,\n      FALSE\n    )\n  )\n\nraw |>\n  count(visoko_koristenje_sm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  visoko_koristenje_sm     n\n  <chr>                <int>\n1 nisko/umjereno         117\n2 visoko                 133\n```\n\n\n:::\n:::\n\n\nFunkcija `if_else()` prima tri argumenta: uvjet, vrijednost za TRUE i vrijednost za FALSE. Prednost nad base R `ifelse()` je što `if_else()` strogo provjerava tipove i daje razumljivije greške kad nešto ne štima.\n\n### Čišćenje stupca godina studija\n\nPogledajmo još jedan neuredan stupac.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw |>\n  count(godina_studija, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 x 2\n   godina_studija     n\n   <chr>          <int>\n 1 2                 54\n 2 1                 52\n 3 3                 38\n 4 3.                22\n 5 1.                19\n 6 4                 19\n 7 druga             14\n 8 5                 12\n 9 2.                 7\n10 treća              7\n11 prva               6\n```\n\n\n:::\n:::\n\n\nImamo \"1\", \"1.\", \"prva\", \"2\", \"2.\", \"druga\" i tako dalje. Sve to treba svesti na konzistentne brojeve.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw <- raw |>\n  mutate(\n    godina_clean = case_when(\n      str_to_lower(godina_studija) %in% c(\"1\", \"1.\", \"prva\") ~ 1,\n      str_to_lower(godina_studija) %in% c(\"2\", \"2.\", \"druga\") ~ 2,\n      str_to_lower(godina_studija) %in% c(\"3\", \"3.\", \"treća\", \"treca\") ~ 3,\n      str_to_lower(godina_studija) %in% c(\"4\", \"4.\", \"četvrta\", \"cetvrta\") ~ 4,\n      str_to_lower(godina_studija) %in% c(\"5\", \"5.\", \"peta\") ~ 5,\n      .default = NA_real_\n    )\n  )\n\nraw |>\n  count(godina_clean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n  godina_clean     n\n         <dbl> <int>\n1            1    77\n2            2    75\n3            3    67\n4            4    19\n5            5    12\n```\n\n\n:::\n:::\n\n\nOvaj put smo neprepoznate vrijednosti kodirali kao `NA_real_` (NA numeričkog tipa) umjesto tekstualne kategorije. To je ispravniji pristup kad očekujemo numerički rezultat. Ako neka vrijednost ne odgovara nijednom poznatom obrascu, bolje je eksplicitno reći \"ne znam\" (NA) nego nagađati.\n\n### Rad s problematičnim numeričkim stupcima\n\nPrisjetimo se da je stupac `tv_min_dan` učitan kao tekst jer sadrži i brojeve i tekst (\"ne gledam\") i prazne ćelije. Moramo ga pretvoriti u broj.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pogledajmo problematične vrijednosti\nraw |>\n  count(tv_min_dan, sort = TRUE) |>\n  head(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 x 2\n   tv_min_dan     n\n   <chr>      <int>\n 1 0             85\n 2 <NA>          41\n 3 ne gledam      6\n 4 71             4\n 5 10             3\n 6 112            3\n 7 119            3\n 8 26             3\n 9 48             3\n10 49             3\n11 51             3\n12 7              3\n13 76             3\n14 82             3\n15 104            2\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# \"ne gledam\" tretiramo kao 0, prazne kao NA\nraw <- raw |>\n  mutate(\n    tv_minuta = case_when(\n      tv_min_dan == \"ne gledam\" ~ 0,\n      tv_min_dan == \"\" ~ NA_real_,\n      .default = as.numeric(tv_min_dan)\n    )\n  )\n\n# Provjera\nraw |>\n  select(tv_min_dan, tv_minuta) |>\n  filter(is.na(tv_minuta) | tv_minuta == 0) |>\n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n   tv_min_dan tv_minuta\n   <chr>          <dbl>\n 1 0                  0\n 2 0                  0\n 3 <NA>              NA\n 4 <NA>              NA\n 5 0                  0\n 6 <NA>              NA\n 7 0                  0\n 8 0                  0\n 9 0                  0\n10 <NA>              NA\n```\n\n\n:::\n:::\n\n\nSada imamo čist numerički stupac `tv_minuta` u kojem je \"ne gledam\" pretvoreno u 0 (jer osoba zaista ne gleda TV, dakle 0 minuta), a prazne ćelije su NA (jer ne znamo koliko ta osoba gleda TV).\n\nOva razlika između 0 i NA je konceptualno važna i vraća nas na tipove nedostajućih vrijednosti koje smo spominjali u tjednu 2. Nula znači \"znamo odgovor, i odgovor je ništa\". NA znači \"ne znamo odgovor\".\n\n---\n\n## arrange(): sortiranje podataka {#sec-arrange}\n\nFunkcija `arrange()` sortira retke po vrijednostima jednog ili više stupaca. Po defaultu sortira uzlazno (od najmanjeg prema najvećem ili abecedno). Za silazno sortiranje koristimo `desc()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sortirano po dobi (najmlađi prvi)\nraw |>\n  select(id_respondenta, dob, grad, drustvene_mreze_min_dan) |>\n  arrange(dob) |>\n  head(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 4\n  id_respondenta   dob grad    drustvene_mreze_min_dan\n           <dbl> <dbl> <chr>                     <dbl>\n1              4    18 Split                        71\n2             23    18 Split                       145\n3             25    18 Osijek                      184\n4             31    18 Zagreb                       97\n5             39    18 Šibenik                     154\n6             44    18 Zagreb                      152\n7             45    18 Pula                         86\n8             57    18 Zagreb                      192\n```\n\n\n:::\n\n```{.r .cell-code}\n# Sortirano po korištenju društvenih mreža (najviše korištenja prvo)\nraw |>\n  select(id_respondenta, dob, grad, drustvene_mreze_min_dan) |>\n  arrange(desc(drustvene_mreze_min_dan)) |>\n  head(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 4\n  id_respondenta   dob grad           drustvene_mreze_min_dan\n           <dbl> <dbl> <chr>                            <dbl>\n1            149    22 Zadar                              296\n2             21    21 Slavonski Brod                     271\n3             42    25 Zagreb                             246\n4             87    18 Zagreb                             246\n5            141    23 Split                              222\n6            181    22 Split                              217\n7             16    19 Split                              214\n8             79    22 Rijeka                             206\n```\n\n\n:::\n:::\n\n\n### Sortiranje po više stupaca\n\nKad sortirate po više stupaca, prvi stupac ima prioritet. Unutar istih vrijednosti prvog stupca, koristi se drugi za razrješenje.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sortiraj po gradu (abecedno), unutar grada po dobi (silazno)\nraw |>\n  select(id_respondenta, grad, dob, drustvene_mreze_min_dan) |>\n  arrange(grad, desc(dob)) |>\n  head(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 4\n   id_respondenta grad        dob drustvene_mreze_min_dan\n            <dbl> <chr>     <dbl>                   <dbl>\n 1            241 Dubrovnik    27                     165\n 2            198 Dubrovnik    25                      99\n 3             34 Dubrovnik    23                     151\n 4            222 Dubrovnik    21                     109\n 5            243 Dubrovnik    20                     117\n 6            129 Dubrovnik    19                     203\n 7             75 Karlovac     28                     115\n 8              8 Karlovac     26                     119\n 9            229 Karlovac     24                     134\n10             15 Karlovac     23                      35\n11             73 Karlovac     21                      20\n12             95 Karlovac     20                     147\n```\n\n\n:::\n:::\n\n\nVidimo da su najprije svi ispitanici iz Dubrovnika (abecedno prvi), unutar kojih je najstariji na vrhu. Zatim dolazi Karlovac, pa dalje.\n\n### Gdje se NA pojavljuje pri sortiranju?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# NA vrijednosti uvijek idu na kraj, bez obzira na smjer\nraw |>\n  select(id_respondenta, radio_min_dan) |>\n  arrange(radio_min_dan) |>\n  tail(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 2\n  id_respondenta radio_min_dan\n           <dbl>         <dbl>\n1            207            NA\n2            211            NA\n3            217            NA\n4            218            NA\n5            219            NA\n6            220            NA\n7            233            NA\n8            244            NA\n```\n\n\n:::\n:::\n\n\nR stavlja NA na kraj sortiranog dataseta, neovisno o tome sortirate li uzlazno ili silazno. Ovo je korisno znati jer ćete ponekad htjeti vidjeti retke s nedostajućim vrijednostima, a oni su uvijek na dnu.\n\n---\n\n## Kombiniranje glagola u pipeline {#sec-pipeline}\n\nPrava snaga dplyr-a nije u pojedinačnim glagolima nego u njihovoj kombinaciji. Pipe operator (`|>`) omogućuje ulančavanje operacija u jednu koherentnu sekvencu koja čita dataseta od početka do kraja, korak po korak.\n\nPogledajmo realistični primjer. Želimo odgovoriti na pitanje: koji gradovi imaju studente koji najviše koriste društvene mreže?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw |>\n  filter(dob >= 18, dob <= 25) |>\n  select(grad, drustvene_mreze_min_dan) |>\n  group_by(grad) |>\n  summarise(\n    n = n(),\n    prosjek = round(mean(drustvene_mreze_min_dan), 1),\n    .groups = \"drop\"\n  ) |>\n  filter(n >= 5) |>\n  arrange(desc(prosjek))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 x 3\n   grad               n prosjek\n   <chr>          <int>   <dbl>\n 1 Slavonski Brod     8   141. \n 2 Zadar             11   137. \n 3 Dubrovnik          5   136. \n 4 Pula               9   134. \n 5 Split             40   133. \n 6 Šibenik            9   127. \n 7 Osijek            18   124. \n 8 Zagreb            79   116. \n 9 Rijeka            18   112. \n10 Varaždin           5    79.6\n11 Karlovac           6    79.3\n```\n\n\n:::\n:::\n\n\nČitamo odozgo prema dolje. Uzmi sirove podatke. Zadrži samo ispitanike između 18 i 25 godina. Odaberi samo stupce za grad i minute korištenja. Grupiraj po gradu. Izračunaj broj ispitanika i prosječno korištenje za svaki grad. Zadrži samo gradove s barem 5 ispitanika (da prosjeci budu smisleni). Sortiraj po prosječnom korištenju od najvišeg prema najnižem.\n\nSvaki korak je sam za sebe jasan, a zajedno tvore kompletnu analizu. Ovo je radni obrazac koji ćete koristiti stotine puta.\n\nPogledajmo drugi primjer. Želimo profil tipičnog korisnika koji često prati vijesti.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw |>\n  filter(prati_vijesti_cesto == TRUE) |>\n  summarise(\n    n = n(),\n    prosjek_dob = round(mean(dob), 1),\n    prosjek_sm_min = round(mean(drustvene_mreze_min_dan), 1),\n    prosjek_portal_min = round(mean(portali_min_dan), 1),\n    prosjek_trust_portal = round(mean(povjerenje_portali_1_10), 1),\n    prosjek_trust_sm = round(mean(povjerenje_drustvene_mreze_1_10), 1)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 6\n      n prosjek_dob prosjek_sm_min prosjek_portal_min prosjek_trust_portal\n  <int>       <dbl>          <dbl>              <dbl>                <dbl>\n1   141        21.9           122.               44.2                  4.9\n# i 1 more variable: prosjek_trust_sm <dbl>\n```\n\n\n:::\n:::\n\n\nLjudi koji prate vijesti barem jednom dnevno provode određen broj minuta na portalima i društvenim mrežama te imaju specifičan profil povjerenja u različite medije. Ova tablica daje bogat uvid u jednom pipeline.\n\n### Pipeline za čišćenje podataka\n\nUobičajena praksa je napisati jedan veliki pipeline za čišćenje koji pretvara sirove podatke u analizi spreman dataset. Evo kako bi to izgledalo za naše podatke.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean <- raw |>\n  # Preimenovanje stupaca za čitljivost\n  rename(\n    id = id_respondenta,\n    sm_min = drustvene_mreze_min_dan,\n    portal_min = portali_min_dan,\n    trust_tv = povjerenje_tv_1_10,\n    trust_portal = povjerenje_portali_1_10,\n    trust_sm = povjerenje_drustvene_mreze_1_10,\n    n_platformi = broj_platformi,\n    vijesti_frekvencija = koliko_cesto_prati_vijesti\n  ) |>\n  # Korištenje već očišćenih stupaca\n  select(\n    id, dob, spol_clean, grad, godina_clean,\n    tv_minuta, portal_min, sm_min, radio_min_dan, podcast_min_dan,\n    trust_tv, trust_portal, trust_sm,\n    n_platformi, vijesti_frekvencija,\n    dobna_skupina, visoko_koristenje_sm, prati_vijesti_cesto\n  ) |>\n  # Završno preimenovanje čistih stupaca\n  rename(\n    spol = spol_clean,\n    godina = godina_clean,\n    radio_min = radio_min_dan,\n    podcast_min = podcast_min_dan\n  )\n\nglimpse(clean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 250\nColumns: 18\n$ id                   <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15~\n$ dob                  <dbl> 20, 27, 27, 18, 25, 26, 28, 26, 22, 21, 22, 27, 2~\n$ spol                 <chr> \"ženski\", \"muški\", \"muški\", \"ženski\", \"ženski\", \"~\n$ grad                 <chr> \"Zagreb\", \"Zadar\", \"Zagreb\", \"Split\", \"Zagreb\", \"~\n$ godina               <dbl> 2, 3, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1~\n$ tv_minuta            <dbl> 0, 0, 65, NA, NA, 91, 91, 0, 76, 66, NA, 109, 0, ~\n$ portal_min           <dbl> 40, 20, 0, 11, 32, 25, 81, 28, 37, 5, 38, 44, 26,~\n$ sm_min               <dbl> 59, 101, 177, 71, 161, 155, 114, 119, 56, 40, 129~\n$ radio_min            <dbl> 49, NA, 0, NA, 26, NA, 0, 0, 17, 0, 0, 13, 0, 0, ~\n$ podcast_min          <dbl> 89, 0, 49, 0, 0, NA, NA, 31, 0, 19, 0, 29, 22, 25~\n$ trust_tv             <dbl> 2, 3, 4, 5, 5, 4, 3, 6, 6, 7, 2, 7, 7, 5, 4, 2, 5~\n$ trust_portal         <dbl> 6, 5, 6, 6, 3, 7, 7, 1, 7, 5, 6, 5, 5, 5, 4, 6, 4~\n$ trust_sm             <dbl> 4, 3, 1, 4, 4, 7, 2, 3, 4, 6, 1, 2, 3, 5, 2, 2, 4~\n$ n_platformi          <dbl> 9, 5, 7, 6, 5, 2, 1, 8, 5, 7, 6, 6, 2, 7, 4, 3, 6~\n$ vijesti_frekvencija  <chr> \"više puta dnevno\", \"nekoliko puta tjedno\", \"više~\n$ dobna_skupina        <chr> \"20-21\", \"24+\", \"24+\", \"18-19\", \"24+\", \"24+\", \"24~\n$ visoko_koristenje_sm <chr> \"nisko/umjereno\", \"nisko/umjereno\", \"visoko\", \"ni~\n$ prati_vijesti_cesto  <lgl> TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRU~\n```\n\n\n:::\n:::\n\n\nSada imamo čist dataset `clean` s razumljivim imenima stupaca, konzistentnim kodiranjem spola i godine studija, numeričkim stupcem za TV minute i binarnim varijablama za visoko korištenje i praćenje vijesti. Ovaj dataset je spreman za deskriptivnu statistiku i vizualizaciju.\n\n> U svakom projektu analize podataka, trebali biste imati jasnu granicu između sirovih podataka (koje nikad ne mijenjate) i čistih podataka (koje kreirate skriptom iz sirovih). Skripta za čišćenje je vaš zapis svakog koraka, i svaki korišten uvjet mora biti dokumentiran komentarima.\n\n---\n\n## Brzi pregled očišćenog dataseta {#sec-pregled}\n\nProvjerimo da je čišćenje uspjelo i iskoristimo priliku da povežemo sve naučene glagole.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Distribucija po spolu\nclean |>\n  count(spol)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  spol       n\n  <chr>  <int>\n1 muški    135\n2 ženski   115\n```\n\n\n:::\n\n```{.r .cell-code}\n# Distribucija po gradu (top 5)\nclean |>\n  count(grad, sort = TRUE) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n  grad       n\n  <chr>  <int>\n1 Zagreb   100\n2 Split     44\n3 Osijek    23\n4 Rijeka    18\n5 Zadar     15\n```\n\n\n:::\n\n```{.r .cell-code}\n# Prosječno korištenje medija po dobnim skupinama\nclean |>\n  group_by(dobna_skupina) |>\n  summarise(\n    n = n(),\n    sm_prosjek = round(mean(sm_min), 1),\n    portal_prosjek = round(mean(portal_min), 1),\n    tv_prosjek = round(mean(tv_minuta, na.rm = TRUE), 1),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  dobna_skupina     n sm_prosjek portal_prosjek tv_prosjek\n  <chr>         <int>      <dbl>          <dbl>      <dbl>\n1 18-19            73       122            42.3       33  \n2 20-21            61       120            43.6       34.4\n3 22-23            47       120.           42.9       35.6\n4 24+              69       122.           42.9       36.1\n```\n\n\n:::\n:::\n\n\nTablica pokazuje jasne razlike. Studenti različitih dobnih skupina imaju različite obrasce korištenja medija. Najmlađi (18 do 19) provode najviše vremena na društvenim mrežama, dok je korištenje portala ravnomjernije raspoređeno. TV je konzistentno najniži oblik medijske konzumacije u svim skupinama, što je očekivano za studentsku populaciju.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Povjerenje u medije: tko kome vjeruje?\nclean |>\n  summarise(\n    trust_tv_prosjek = round(mean(trust_tv), 1),\n    trust_portal_prosjek = round(mean(trust_portal), 1),\n    trust_sm_prosjek = round(mean(trust_sm), 1)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  trust_tv_prosjek trust_portal_prosjek trust_sm_prosjek\n             <dbl>                <dbl>            <dbl>\n1              4.5                    5              3.4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Povjerenje po spolu\nclean |>\n  group_by(spol) |>\n  summarise(\n    n = n(),\n    trust_sm = round(mean(trust_sm), 1),\n    trust_portal = round(mean(trust_portal), 1),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 4\n  spol       n trust_sm trust_portal\n  <chr>  <int>    <dbl>        <dbl>\n1 muški    135      3.3          4.9\n2 ženski   115      3.5          5.1\n```\n\n\n:::\n:::\n\n\nStudenti u prosjeku najviše vjeruju portalima, zatim televiziji, a najmanje društvenim mrežama. Ovo je zanimljiv nalaz jer istovremeno na društvenim mrežama provode daleko najviše vremena. Provode li ljudi najviše vremena na medijima kojima najmanje vjeruju? Ili se povjerenje gradi korištenjem? Ovo su pitanja na koja ćemo se vraćati kad budemo radili korelacije i regresiju u kasnijim tjednima.\n\n---\n\n## group_by() i summarise(): statistike po grupama {#sec-group-by}\n\nKombinaciju `group_by()` i `summarise()` smo već koristili u dosadašnjim primjerima, ali zaslužuje detaljniju obradu jer je ovo daleko najvažniji obrazac u cijelom tidyverse radnom toku. Gotovo svaka analiza u komunikologiji uključuje usporedbu između grupa: razlikuju li se muškarci i žene po korištenju medija? Razlikuju li se gradovi po povjerenju? Razlikuju li se generacije po izvorima vijesti?\n\n### Osnovna logika\n\n`group_by()` dijeli tibble na nevidljive podskupove prema vrijednostima jednog ili više stupaca. Sam po sebi ne proizvodi nikakav vidljiv rezultat. Ali kad nakon njega pozovete `summarise()`, izračun se ponavlja zasebno za svaki podskup.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prosječno korištenje društvenih mreža po spolu\nclean |>\n  group_by(spol) |>\n  summarise(\n    n = n(),\n    prosjek_sm = round(mean(sm_min), 1),\n    sd_sm = round(sd(sm_min), 1),\n    medijan_sm = median(sm_min),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 5\n  spol       n prosjek_sm sd_sm medijan_sm\n  <chr>  <int>      <dbl> <dbl>      <dbl>\n1 muški    135       117.  49.2        115\n2 ženski   115       126.  47.3        129\n```\n\n\n:::\n:::\n\n\nArgument `.groups = \"drop\"` na kraju govori R-u da ukloni grupiranje nakon izračuna. Bez njega, rezultirajući tibble bi ostao grupiran, što može uzrokovati neočekivano ponašanje u kasnijim operacijama. Dobra praksa je uvijek eksplicitno navesti `.groups = \"drop\"`.\n\n### Grupiranje po više varijabli\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Korištenje po spolu i dobnoj skupini\nclean |>\n  group_by(spol, dobna_skupina) |>\n  summarise(\n    n = n(),\n    prosjek_sm = round(mean(sm_min), 1),\n    prosjek_portal = round(mean(portal_min), 1),\n    .groups = \"drop\"\n  ) |>\n  filter(spol != \"ostalo\") |>\n  arrange(dobna_skupina, spol)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 5\n  spol   dobna_skupina     n prosjek_sm prosjek_portal\n  <chr>  <chr>         <int>      <dbl>          <dbl>\n1 muški  18-19            39       122.           40.2\n2 ženski 18-19            34       122.           44.7\n3 muški  20-21            36       114.           41.4\n4 ženski 20-21            25       128.           46.8\n5 muški  22-23            24       110.           44.1\n6 ženski 22-23            23       130.           41.7\n7 muški  24+              36       119.           42.9\n8 ženski 24+              33       126.           43  \n```\n\n\n:::\n:::\n\n\nKad grupirate po više varijabli, `summarise()` izračunava statistike za svaku kombinaciju tih varijabli. S dva spola i četiri dobne skupine dobivate osam grupa (ili manje, ako neke kombinacije nemaju opažanja). Filtrirali smo kategoriju \"ostalo\" jer s malim brojem opažanja statistike nisu pouzdane.\n\n### count() kao kratica\n\nFunkcija `count()` je zapravo kratica za `group_by() |> summarise(n = n()) |> ungroup()`. Koristite je kad vam treba samo prebrojavanje.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ovo:\nclean |>\n  count(grad, sort = TRUE) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n  grad       n\n  <chr>  <int>\n1 Zagreb   100\n2 Split     44\n3 Osijek    23\n4 Rijeka    18\n5 Zadar     15\n```\n\n\n:::\n\n```{.r .cell-code}\n# Je ekvivalentno ovome:\nclean |>\n  group_by(grad) |>\n  summarise(n = n(), .groups = \"drop\") |>\n  arrange(desc(n)) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n  grad       n\n  <chr>  <int>\n1 Zagreb   100\n2 Split     44\n3 Osijek    23\n4 Rijeka    18\n5 Zadar     15\n```\n\n\n:::\n:::\n\n\nObje verzije daju identičan rezultat, ali `count()` štedi tri reda koda. Za jednostavno prebrojavanje uvijek koristite `count()`.\n\n### group_by() s mutate()\n\nManje poznata ali izuzetno korisna kombinacija je `group_by()` s `mutate()`. Umjesto da sažima podatke u jednu vrijednost po grupi (kao `summarise()`), `mutate()` dodaje novu kolonu svakom retku, ali izračun se radi unutar grupe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Z-score korištenja društvenih mreža UNUTAR svake dobne skupine\nclean |>\n  group_by(dobna_skupina) |>\n  mutate(\n    sm_prosjek_grupe = mean(sm_min),\n    sm_z = round((sm_min - mean(sm_min)) / sd(sm_min), 2)\n  ) |>\n  ungroup() |>\n  select(id, dob, dobna_skupina, sm_min, sm_prosjek_grupe, sm_z) |>\n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 6\n      id   dob dobna_skupina sm_min sm_prosjek_grupe  sm_z\n   <dbl> <dbl> <chr>          <dbl>            <dbl> <dbl>\n 1     1    20 20-21             59             120. -1.24\n 2     2    27 24+              101             122. -0.53\n 3     3    27 24+              177             122.  1.33\n 4     4    18 18-19             71             122. -0.98\n 5     5    25 24+              161             122.  0.94\n 6     6    26 24+              155             122.  0.79\n 7     7    28 24+              114             122. -0.21\n 8     8    26 24+              119             122. -0.09\n 9     9    22 22-23             56             120. -1.2 \n10    10    21 20-21             40             120. -1.62\n```\n\n\n:::\n:::\n\n\nPrimijetite `ungroup()` na kraju. Kad koristite `group_by()` s `mutate()`, grupiranje ostaje aktivno nakon mutatea (za razliku od `summarise()` koji ga automatski smanjuje). Uvijek dodajte `ungroup()` kad završite s grupiranim operacijama da izbjegnete iznenađenja.\n\n---\n\n## across(): ista operacija na više stupaca {#sec-across}\n\nDo sada smo u `summarise()` ručno pisali svaku statistiku za svaki stupac. Kad imate pet ili deset numeričkih stupaca, to postaje zamorno. Funkcija `across()` rješava ovaj problem jer primjenjuje istu funkciju (ili više funkcija) na više stupaca odjednom.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prosjek za sve stupce koji sadrže \"trust\" u imenu\nclean |>\n  summarise(\n    across(starts_with(\"trust\"), ~round(mean(.x), 1))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 3\n  trust_tv trust_portal trust_sm\n     <dbl>        <dbl>    <dbl>\n1      4.5            5      3.4\n```\n\n\n:::\n:::\n\n\nSintaksa `~round(mean(.x), 1)` koristi lambda notaciju (tilda formula). `.x` je placeholder za svaki stupac na koji se `across()` primjenjuje. Ovo se čita kao \"za svaki stupac koji počinje s trust, izračunaj zaokruženi prosjek\".\n\n### Više funkcija odjednom\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prosjek i SD za stupce s minutama\nclean |>\n  summarise(\n    across(\n      c(sm_min, portal_min, tv_minuta),\n      list(\n        prosjek = ~round(mean(.x, na.rm = TRUE), 1),\n        sd = ~round(sd(.x, na.rm = TRUE), 1)\n      ),\n      .names = \"{.col}_{.fn}\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 6\n  sm_min_prosjek sm_min_sd portal_min_prosjek portal_min_sd tv_minuta_prosjek\n           <dbl>     <dbl>              <dbl>         <dbl>             <dbl>\n1           121.      48.5               42.9          22.3              34.7\n# i 1 more variable: tv_minuta_sd <dbl>\n```\n\n\n:::\n:::\n\n\nKad proslijedite imenovanu listu funkcija, `across()` kreira zasebne stupce za svaku kombinaciju stupca i funkcije. Argument `.names = \"{.col}_{.fn}\"` kontrolira kako se novi stupci imenuju: `{.col}` je ime izvornog stupca, `{.fn}` je ime funkcije iz liste.\n\n### across() s group_by()\n\nKombinacija `across()` i `group_by()` omogućuje izračun više statistika za više stupaca po grupama, u jednom kompaktnom pozivu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean |>\n  group_by(dobna_skupina) |>\n  summarise(\n    n = n(),\n    across(\n      c(sm_min, portal_min, trust_sm, trust_portal),\n      list(M = ~round(mean(.x, na.rm = TRUE), 1)),\n      .names = \"{.col}_{.fn}\"\n    ),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 6\n  dobna_skupina     n sm_min_M portal_min_M trust_sm_M trust_portal_M\n  <chr>         <int>    <dbl>        <dbl>      <dbl>          <dbl>\n1 18-19            73     122          42.3        3.5            4.9\n2 20-21            61     120          43.6        3.4            4.9\n3 22-23            47     120.         42.9        3.5            5  \n4 24+              69     122.         42.9        3.3            5.2\n```\n\n\n:::\n:::\n\n\nU jednom pozivu dobivamo prosjeke četiri varijable za svaku dobnu skupinu, plus broj opažanja. Ovo je obrazac koji ćete koristiti za izradu tablica deskriptivnih statistika u akademskim radovima.\n\n### across() s mutate()\n\n`across()` radi i unutar `mutate()` za transformaciju više stupaca odjednom.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Centriranje svih trust varijabli (oduzimanje prosjeka)\nclean |>\n  mutate(\n    across(\n      starts_with(\"trust\"),\n      ~.x - mean(.x),\n      .names = \"{.col}_cent\"\n    )\n  ) |>\n  select(id, starts_with(\"trust\")) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 7\n     id trust_tv trust_portal trust_sm trust_tv_cent trust_portal_cent\n  <dbl>    <dbl>        <dbl>    <dbl>         <dbl>             <dbl>\n1     1        2            6        4        -2.48            0.992  \n2     2        3            5        3        -1.48           -0.00800\n3     3        4            6        1        -0.476           0.992  \n4     4        5            6        4         0.524           0.992  \n5     5        5            3        4         0.524          -2.01   \n# i 1 more variable: trust_sm_cent <dbl>\n```\n\n\n:::\n:::\n\n\nOvo je osobito korisno za standardizaciju ili transformaciju velikog broja varijabli u jednom koraku.\n\n::: {.callout-tip}\n## Praktični savjet\n\nFunkcija `across()` čini kod kompaktnijim ali i teže čitljivim za početnike. Ako vam lambda notacija (`~mean(.x)`) izgleda zbunjujuće, nema ništa loše u tome da najprije pišete svaku statistiku ručno, a `across()` počnete koristiti kad se osjećate ugodno s osnovnim glagolima. Cilj je čitljivost, ne kratkoća.\n:::\n\n---\n\n## pivot_longer() i pivot_wider(): preoblikovanje podataka {#sec-pivot}\n\nPonekad podaci dolaze u obliku koji nije pogodan za analizu ili vizualizaciju i moramo ih preoblikovati. Dva najčešća slučaja su pretvaranje širokog formata u dugački i obrnuto.\n\n### Tidy data: princip urednih podataka\n\nWickham (2014) definira **uredne podatke** (tidy data) kao tablicu u kojoj svaki redak predstavlja jedno opažanje, svaki stupac jednu varijablu i svaka ćelija jednu vrijednost. Zvuči jednostavno, ali mnogi dataseti ne zadovoljavaju ovaj princip.\n\nPogledajmo konkretan primjer. Naši podaci o povjerenju imaju tri zasebna stupca: `trust_tv`, `trust_portal`, `trust_sm`. Za neke analize (posebno vizualizaciju), bilo bi korisnije imati jedan stupac `medij` s vrijednostima \"TV\", \"portal\" i \"društvene mreže\" i jedan stupac `povjerenje` s numeričkom ocjenom.\n\n### pivot_longer(): od širokog prema dugačkom\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrust_long <- clean |>\n  select(id, dob, spol, dobna_skupina, trust_tv, trust_portal, trust_sm) |>\n  pivot_longer(\n    cols = starts_with(\"trust\"),\n    names_to = \"medij\",\n    values_to = \"povjerenje\",\n    names_prefix = \"trust_\"\n  )\n\ntrust_long |>\n  head(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 6\n      id   dob spol   dobna_skupina medij  povjerenje\n   <dbl> <dbl> <chr>  <chr>         <chr>       <dbl>\n 1     1    20 ženski 20-21         tv              2\n 2     1    20 ženski 20-21         portal          6\n 3     1    20 ženski 20-21         sm              4\n 4     2    27 muški  24+           tv              3\n 5     2    27 muški  24+           portal          5\n 6     2    27 muški  24+           sm              3\n 7     3    27 muški  24+           tv              4\n 8     3    27 muški  24+           portal          6\n 9     3    27 muški  24+           sm              1\n10     4    18 ženski 18-19         tv              5\n11     4    18 ženski 18-19         portal          6\n12     4    18 ženski 18-19         sm              4\n```\n\n\n:::\n:::\n\n\nFunkcija `pivot_longer()` pretvara stupce u redove. Argumenti su:\n\n**`cols`** specificira koje stupce pretvaramo (ovdje sve koji počinju s \"trust\").\n\n**`names_to`** je ime novog stupca koji će sadržavati imena izvornih stupaca.\n\n**`values_to`** je ime novog stupca koji će sadržavati vrijednosti iz izvornih stupaca.\n\n**`names_prefix`** uklanja zajednički prefiks iz imena (bez njega bismo imali \"trust_tv\" umjesto \"tv\").\n\nIz originalnih 250 redova (jedan po ispitaniku) dobili smo 750 redova (tri po ispitaniku, jedan za svaki tip medija). Ovo je dugački format.\n\nSad možemo lako izračunati prosječno povjerenje po tipu medija.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrust_long |>\n  group_by(medij) |>\n  summarise(\n    prosjek = round(mean(povjerenje), 2),\n    sd = round(sd(povjerenje), 2),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  medij  prosjek    sd\n  <chr>    <dbl> <dbl>\n1 portal    5.01  1.73\n2 sm        3.41  1.72\n3 tv        4.48  1.99\n```\n\n\n:::\n:::\n\n\nIli po tipu medija i dobnoj skupini.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrust_long |>\n  group_by(dobna_skupina, medij) |>\n  summarise(\n    prosjek = round(mean(povjerenje), 1),\n    .groups = \"drop\"\n  ) |>\n  arrange(dobna_skupina, medij)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 3\n   dobna_skupina medij  prosjek\n   <chr>         <chr>    <dbl>\n 1 18-19         portal     4.9\n 2 18-19         sm         3.5\n 3 18-19         tv         4.6\n 4 20-21         portal     4.9\n 5 20-21         sm         3.4\n 6 20-21         tv         4.8\n 7 22-23         portal     5  \n 8 22-23         sm         3.5\n 9 22-23         tv         4.1\n10 24+           portal     5.2\n11 24+           sm         3.3\n12 24+           tv         4.4\n```\n\n\n:::\n:::\n\n\nOva tablica jasno pokazuje obrasce koje bi bilo teško vidjeti u širokom formatu. Dugački format je posebno koristan za vizualizaciju jer ggplot2 (koji ćemo učiti sljedeći tjedan) radi prirodno s dugačkim podacima.\n\n### pivot_wider(): od dugačkog prema širokom\n\nObrnuta operacija, `pivot_wider()`, pretvara redove u stupce. Korisna je kad želite tablicu u obliku koji je čitljiv za ljude (široki format), a ne za računalo (dugački format).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prosječno povjerenje po dobnoj skupini i mediju, u širokom formatu\ntrust_long |>\n  group_by(dobna_skupina, medij) |>\n  summarise(prosjek = round(mean(povjerenje), 1), .groups = \"drop\") |>\n  pivot_wider(\n    names_from = medij,\n    values_from = prosjek\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 4\n  dobna_skupina portal    sm    tv\n  <chr>          <dbl> <dbl> <dbl>\n1 18-19            4.9   3.5   4.6\n2 20-21            4.9   3.4   4.8\n3 22-23            5     3.5   4.1\n4 24+              5.2   3.3   4.4\n```\n\n\n:::\n:::\n\n\nRezultat je tablica s jednim retkom po dobnoj skupini i jednim stupcem po tipu medija. Ovo je format koji biste stavili u izvještaj ili akademski rad jer je lako čitljiv.\n\nArgumenti su zrcalni u odnosu na `pivot_longer()`:\n\n**`names_from`** je stupac čije će vrijednosti postati imena novih stupaca.\n\n**`values_from`** je stupac čije će vrijednosti popuniti nove stupce.\n\n### Primjer s minutama korištenja\n\nIsti obrazac primjenjujemo i na podatke o korištenju medija.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pretvorba minuta korištenja u dugački format\nkoristenje_long <- clean |>\n  select(id, dob, spol, dobna_skupina, tv_minuta, portal_min, sm_min) |>\n  pivot_longer(\n    cols = c(tv_minuta, portal_min, sm_min),\n    names_to = \"medij\",\n    values_to = \"minuta\"\n  ) |>\n  mutate(\n    medij = case_when(\n      medij == \"tv_minuta\" ~ \"TV\",\n      medij == \"portal_min\" ~ \"Portali\",\n      medij == \"sm_min\" ~ \"Društvene mreže\"\n    )\n  )\n\n# Prosječno korištenje po tipu medija\nkoristenje_long |>\n  group_by(medij) |>\n  summarise(\n    prosjek = round(mean(minuta, na.rm = TRUE), 1),\n    medijan = median(minuta, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |>\n  arrange(desc(prosjek))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 3\n  medij           prosjek medijan\n  <chr>             <dbl>   <dbl>\n1 Društvene mreže   121.      124\n2 Portali            42.9      43\n3 TV                 34.7      17\n```\n\n\n:::\n:::\n\n\nDruštvene mreže dominiraju s velikim razmakom. TV je daleko na dnu. Ovi podaci su za studentsku populaciju, pa ne iznenađuju, ali upravo ovakve tablice čine temelj svakog izvještaja o medijskim navikama.\n\n::: {.callout-important}\n## Važna napomena\n\nZapamtite pravilo: `pivot_longer()` koristite kad želite pretvoriti podatke iz oblika čitljivog za ljude u oblik pogodan za analizu i vizualizaciju. `pivot_wider()` koristite kad želite rezultate pretvoriti natrag u oblik čitljiv za ljude (za tablice u izvještajima). Tipičan radni tok je: učitajte podatke, pretvorite u dugački format, analizirajte, pretvorite rezultate u široki format za prezentaciju.\n:::\n\n---\n\n## Spajanje tablica: left_join() {#sec-join}\n\nU stvarnim istraživanjima, podaci rijetko dolaze u jednoj tablici. Možda imate jednu tablicu s demografskim podacima ispitanika i drugu s rezultatima eksperimenta. Ili jednu tablicu s podacima o člancima i drugu s podacima o komentarima. Da biste ih analizirali zajedno, morate ih spojiti.\n\nKreirajmo pomoćnu tablicu za demonstraciju.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tablica s informacijama o gradovima\ngradovi_info <- tibble(\n  grad = c(\"Zagreb\", \"Split\", \"Rijeka\", \"Osijek\", \"Zadar\", \"Dubrovnik\",\n           \"Slavonski Brod\", \"Pula\", \"Karlovac\", \"Varaždin\", \"Šibenik\", \"Sisak\"),\n  regija = c(\"Središnja\", \"Dalmacija\", \"Primorje\", \"Slavonija\", \"Dalmacija\", \"Dalmacija\",\n             \"Slavonija\", \"Istra\", \"Središnja\", \"Sjever\", \"Dalmacija\", \"Središnja\"),\n  populacija_tis = c(770, 160, 108, 96, 70, 41, 50, 52, 46, 41, 34, 33)\n)\n\ngradovi_info\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 3\n   grad           regija    populacija_tis\n   <chr>          <chr>              <dbl>\n 1 Zagreb         Središnja            770\n 2 Split          Dalmacija            160\n 3 Rijeka         Primorje             108\n 4 Osijek         Slavonija             96\n 5 Zadar          Dalmacija             70\n 6 Dubrovnik      Dalmacija             41\n 7 Slavonski Brod Slavonija             50\n 8 Pula           Istra                 52\n 9 Karlovac       Središnja             46\n10 Varaždin       Sjever                41\n11 Šibenik        Dalmacija             34\n12 Sisak          Središnja             33\n```\n\n\n:::\n:::\n\n\nSada možemo spojiti ovu tablicu s našim čistim podacima da svakom ispitaniku dodamo informaciju o regiji i populaciji grada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_s_regijom <- clean |>\n  left_join(gradovi_info, by = \"grad\")\n\nclean_s_regijom |>\n  select(id, grad, regija, populacija_tis, sm_min) |>\n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 5\n      id grad     regija    populacija_tis sm_min\n   <dbl> <chr>    <chr>              <dbl>  <dbl>\n 1     1 Zagreb   Središnja            770     59\n 2     2 Zadar    Dalmacija             70    101\n 3     3 Zagreb   Središnja            770    177\n 4     4 Split    Dalmacija            160     71\n 5     5 Zagreb   Središnja            770    161\n 6     6 Zagreb   Središnja            770    155\n 7     7 Zagreb   Središnja            770    114\n 8     8 Karlovac Središnja             46    119\n 9     9 Split    Dalmacija            160     56\n10    10 Osijek   Slavonija             96     40\n```\n\n\n:::\n:::\n\n\nFunkcija `left_join()` spaja dvije tablice po zajedničkom stupcu (ovdje `grad`). Za svaki redak u lijevoj tablici (`clean`), traži podudarajući redak u desnoj tablici (`gradovi_info`) i dodaje stupce iz desne tablice. Ako nema podudaranja (na primjer, grad koji nije u tablici `gradovi_info`), dobivamo NA.\n\nArgument `by = \"grad\"` specificira koji stupac koristimo za podudaranje. Ako se stupac za spajanje različito zove u dvjema tablicama, koristimo sintaksu `by = c(\"ime_lijevo\" = \"ime_desno\")`.\n\nSad možemo analizirati podatke po regijama.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_s_regijom |>\n  group_by(regija) |>\n  summarise(\n    n = n(),\n    prosjek_sm = round(mean(sm_min), 1),\n    prosjek_trust_sm = round(mean(trust_sm), 1),\n    .groups = \"drop\"\n  ) |>\n  filter(!is.na(regija)) |>\n  arrange(desc(prosjek_sm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 x 4\n  regija        n prosjek_sm prosjek_trust_sm\n  <chr>     <int>      <dbl>            <dbl>\n1 Istra        10       140               3  \n2 Dalmacija    74       132.              3.2\n3 Slavonija    31       127.              3.5\n4 Središnja   110       115.              3.6\n5 Primorje     18       112.              3.4\n6 Sjever        7        79               3.3\n```\n\n\n:::\n:::\n\n\nOvo je moć spajanja tablica: informacija koja je bila u zasebnoj tablici sada je dio naše analize i omogućuje grupiranje po varijabli koja nije postojala u izvornim podacima.\n\n### Vrste joinova\n\n`left_join()` je daleko najčešći join i jedini koji ćete trebati u većini situacija. Ali vrijedi znati da postoje i drugi.\n\n**`left_join(a, b)`** zadržava sve retke iz a, dodaje podudarajuće iz b. Ako nema podudaranja, NA.\n\n**`inner_join(a, b)`** zadržava samo retke koji postoje u obje tablice.\n\n**`full_join(a, b)`** zadržava sve retke iz obje tablice, s NA gdje nema podudaranja.\n\n**`anti_join(a, b)`** zadržava retke iz a koji nemaju podudaranje u b. Korisno za pronalaženje nepodudarajućih zapisa.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ima li ispitanika iz gradova koji nisu u našoj tablici?\nclean |>\n  anti_join(gradovi_info, by = \"grad\") |>\n  count(grad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 x 2\n# i 2 variables: grad <chr>, n <int>\n```\n\n\n:::\n:::\n\n\n`anti_join()` je odličan dijagnostički alat jer otkriva retke koji se ne mogu spojiti. U ovom slučaju vidimo gradove koji postoje u anketi ali ne u našoj tablici gradova.\n\n---\n\n## Stringovi: osnove rada s tekstom {#sec-stringovi}\n\nU komunikologiji se često radi s tekstualnim podacima: imena platformi, naslovi članaka, otvoreni odgovori u anketama. Paket stringr (dio tidyverse) pruža konzistentan skup funkcija za rad s tekstom.\n\nVeć smo koristili `str_to_lower()` i `str_detect()`. Pogledajmo još nekoliko korisnih funkcija.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Stupac s platformama je slobodan tekst s više unosa\nraw |>\n  select(id_respondenta, koje_platforme_koristi) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n  id_respondenta koje_platforme_koristi      \n           <dbl> <chr>                       \n1              1 Snapchat, WhatsApp, Facebook\n2              2 Facebook, YouTube           \n3              3 WhatsApp                    \n4              4 Pinterest, LinkedIn         \n5              5 Viber, Snapchat, Reddit     \n```\n\n\n:::\n\n```{.r .cell-code}\n# Koliko ispitanika koristi Instagram (bilo gdje u tekstu)?\nraw |>\n  mutate(koristi_instagram = str_detect(koje_platforme_koristi, \"Instagram\")) |>\n  count(koristi_instagram)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  koristi_instagram     n\n  <lgl>             <int>\n1 FALSE               211\n2 TRUE                 39\n```\n\n\n:::\n:::\n\n\n### Brojanje i izdvajanje uzoraka\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Koliko platformi svaki ispitanik navodi (brojeći zareze + 1)?\nraw |>\n  mutate(\n    navedeno_platformi = str_count(koje_platforme_koristi, \",\") + 1\n  ) |>\n  select(id_respondenta, koje_platforme_koristi, navedeno_platformi) |>\n  head(8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 x 3\n  id_respondenta koje_platforme_koristi                 navedeno_platformi\n           <dbl> <chr>                                               <dbl>\n1              1 Snapchat, WhatsApp, Facebook                            3\n2              2 Facebook, YouTube                                       2\n3              3 WhatsApp                                                1\n4              4 Pinterest, LinkedIn                                     2\n5              5 Viber, Snapchat, Reddit                                 3\n6              6 Pinterest, YouTube                                      2\n7              7 WhatsApp                                                1\n8              8 Reddit, Pinterest, WhatsApp, Twitter/X                  4\n```\n\n\n:::\n:::\n\n\nFunkcija `str_count()` broji koliko se puta uzorak pojavljuje u tekstu. Budući da su platforme odvojene zarezima, broj zareza plus jedan daje broj navedenih platformi. Ovo je primjer kako tekstualne operacije pomažu u izvlačenju numeričkih informacija iz nestrukturiranih podataka.\n\n### Zamjena i čišćenje teksta\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Zamjena \"Twitter/X\" s \"X\" za konzistentnost\nraw |>\n  mutate(\n    platforme_clean = str_replace(koje_platforme_koristi, \"Twitter/X\", \"X\")\n  ) |>\n  filter(str_detect(koje_platforme_koristi, \"Twitter\")) |>\n  select(koje_platforme_koristi, platforme_clean) |>\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 x 2\n  koje_platforme_koristi                    platforme_clean                  \n  <chr>                                     <chr>                            \n1 Reddit, Pinterest, WhatsApp, Twitter/X    Reddit, Pinterest, WhatsApp, X   \n2 YouTube, Twitter/X, Pinterest, WhatsApp   YouTube, X, Pinterest, WhatsApp  \n3 Pinterest, Instagram, Telegram, Twitter/X Pinterest, Instagram, Telegram, X\n4 Reddit, Twitter/X, Pinterest              Reddit, X, Pinterest             \n5 LinkedIn, Telegram, Snapchat, Twitter/X   LinkedIn, Telegram, Snapchat, X  \n```\n\n\n:::\n:::\n\n\nFunkcija `str_replace()` zamjenjuje prvo pojavljivanje uzorka, a `str_replace_all()` zamjenjuje sva pojavljivanja. Funkcija `str_trim()` uklanja razmake s početka i kraja teksta, što je korisno kad ispitanici slučajno unesu razmak.\n\n---\n\n## Sve zajedno: kompletna analiza od sirovih do gotovih podataka {#sec-kompletna}\n\nZaokružimo ovo predavanje tako da napišemo kompletnu analizu koja prolazi kroz sve faze: učitavanje, čišćenje, transformaciju, analizu i prezentaciju rezultata. Ovo je obrazac koji ćete ponavljati u svakom projektu.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# FAZA 1: Učitavanje i čišćenje\nanketa_clean <- read_csv(\"../resources/datasets/media_habits_raw.csv\") |>\n  clean_names() |>\n  mutate(\n    # Čišćenje spola\n    spol = case_when(\n      str_to_lower(spol) %in% c(\"ženski\", \"ž\", \"zensko\", \"female\") ~ \"ženski\",\n      str_to_lower(spol) %in% c(\"muški\", \"m\", \"musko\", \"male\") ~ \"muški\",\n      .default = NA_character_\n    ),\n    # Čišćenje godine studija\n    godina = case_when(\n      str_to_lower(godina_studija) %in% c(\"1\", \"1.\", \"prva\") ~ 1L,\n      str_to_lower(godina_studija) %in% c(\"2\", \"2.\", \"druga\") ~ 2L,\n      str_to_lower(godina_studija) %in% c(\"3\", \"3.\", \"treća\", \"treca\") ~ 3L,\n      str_to_lower(godina_studija) %in% c(\"4\", \"4.\") ~ 4L,\n      str_to_lower(godina_studija) %in% c(\"5\", \"5.\") ~ 5L,\n      .default = NA_integer_\n    ),\n    # TV minute: text -> broj\n    tv_min = case_when(\n      tv_min_dan == \"ne gledam\" ~ 0,\n      tv_min_dan == \"\" ~ NA_real_,\n      .default = as.numeric(tv_min_dan)\n    ),\n    # Dobna skupina\n    dobna_sk = case_when(\n      dob < 20 ~ \"18-19\",\n      dob < 22 ~ \"20-21\",\n      dob < 24 ~ \"22-23\",\n      dob >= 24 ~ \"24+\"\n    )\n  ) |>\n  # Odabir i preimenovanje konačnih stupaca\n  select(\n    id = id_respondenta,\n    dob, spol, grad, godina,\n    tv_min,\n    portal_min = portali_min_dan,\n    sm_min = drustvene_mreze_min_dan,\n    trust_tv = povjerenje_tv_1_10,\n    trust_portal = povjerenje_portali_1_10,\n    trust_sm = povjerenje_drustvene_mreze_1_10,\n    vijesti = koliko_cesto_prati_vijesti,\n    dobna_sk\n  )\n\nglimpse(anketa_clean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 250\nColumns: 13\n$ id           <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17~\n$ dob          <dbl> 20, 27, 27, 18, 25, 26, 28, 26, 22, 21, 22, 27, 20, 20, 2~\n$ spol         <chr> \"ženski\", \"muški\", \"muški\", \"ženski\", \"ženski\", \"muški\", ~\n$ grad         <chr> \"Zagreb\", \"Zadar\", \"Zagreb\", \"Split\", \"Zagreb\", \"Zagreb\",~\n$ godina       <int> 2, 3, 1, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1, 2, ~\n$ tv_min       <dbl> 0, 0, 65, NA, NA, 91, 91, 0, 76, 66, NA, 109, 0, 0, 56, 0~\n$ portal_min   <dbl> 40, 20, 0, 11, 32, 25, 81, 28, 37, 5, 38, 44, 26, 65, 35,~\n$ sm_min       <dbl> 59, 101, 177, 71, 161, 155, 114, 119, 56, 40, 129, 95, 72~\n$ trust_tv     <dbl> 2, 3, 4, 5, 5, 4, 3, 6, 6, 7, 2, 7, 7, 5, 4, 2, 5, 3, 4, ~\n$ trust_portal <dbl> 6, 5, 6, 6, 3, 7, 7, 1, 7, 5, 6, 5, 5, 5, 4, 6, 4, 5, 6, ~\n$ trust_sm     <dbl> 4, 3, 1, 4, 4, 7, 2, 3, 4, 6, 1, 2, 3, 5, 2, 2, 4, 3, 6, ~\n$ vijesti      <chr> \"više puta dnevno\", \"nekoliko puta tjedno\", \"više puta dn~\n$ dobna_sk     <chr> \"20-21\", \"24+\", \"24+\", \"18-19\", \"24+\", \"24+\", \"24+\", \"24+~\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# FAZA 2: Provjera\n# Koliko NA po stupcu?\nanketa_clean |>\n  summarise(across(everything(), ~sum(is.na(.x)))) |>\n  pivot_longer(everything(), names_to = \"stupac\", values_to = \"n_NA\") |>\n  filter(n_NA > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 2\n  stupac  n_NA\n  <chr>  <int>\n1 tv_min    41\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# FAZA 3: Deskriptivna analiza\n# Korištenje medija po dobnoj skupini\nanketa_clean |>\n  group_by(dobna_sk) |>\n  summarise(\n    n = n(),\n    across(\n      c(sm_min, portal_min, tv_min),\n      list(M = ~round(mean(.x, na.rm = TRUE), 1)),\n      .names = \"{.col}_{.fn}\"\n    ),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 x 5\n  dobna_sk     n sm_min_M portal_min_M tv_min_M\n  <chr>    <int>    <dbl>        <dbl>    <dbl>\n1 18-19       73     122          42.3     33  \n2 20-21       61     120          43.6     34.4\n3 22-23       47     120.         42.9     35.6\n4 24+         69     122.         42.9     36.1\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Povjerenje po tipu medija (dugački format za lakšu usporedbu)\nanketa_clean |>\n  pivot_longer(\n    cols = starts_with(\"trust\"),\n    names_to = \"medij\",\n    values_to = \"povjerenje\",\n    names_prefix = \"trust_\"\n  ) |>\n  mutate(\n    medij = case_when(\n      medij == \"tv\" ~ \"Televizija\",\n      medij == \"portal\" ~ \"Web portali\",\n      medij == \"sm\" ~ \"Društvene mreže\"\n    )\n  ) |>\n  group_by(medij) |>\n  summarise(\n    M = round(mean(povjerenje), 2),\n    SD = round(sd(povjerenje), 2),\n    Med = median(povjerenje),\n    .groups = \"drop\"\n  ) |>\n  arrange(desc(M))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 4\n  medij               M    SD   Med\n  <chr>           <dbl> <dbl> <dbl>\n1 Web portali      5.01  1.73     5\n2 Televizija       4.48  1.99     4\n3 Društvene mreže  3.41  1.72     3\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tko prati vijesti, a tko ne?\nanketa_clean |>\n  mutate(\n    cesto_prati = vijesti %in% c(\"više puta dnevno\", \"jednom dnevno\")\n  ) |>\n  group_by(cesto_prati) |>\n  summarise(\n    n = n(),\n    prosjek_dob = round(mean(dob), 1),\n    prosjek_sm = round(mean(sm_min), 1),\n    prosjek_trust_portal = round(mean(trust_portal), 1),\n    prosjek_trust_sm = round(mean(trust_sm), 1),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 6\n  cesto_prati     n prosjek_dob prosjek_sm prosjek_trust_portal prosjek_trust_sm\n  <lgl>       <int>       <dbl>      <dbl>                <dbl>            <dbl>\n1 FALSE         109        21.6       120.                  5.2              3.3\n2 TRUE          141        21.9       122.                  4.9              3.5\n```\n\n\n:::\n:::\n\n\nOva kompletna analiza, od učitavanja sirovih podataka do gotovih tablica, stane u manje od 80 redova koda. Svaki korak je dokumentiran, ponovljiv i čitljiv. Ako sutra dobijete ažurirane podatke s još 100 ispitanika, pokrenete istu skriptu i dobijete ažurirane rezultate. To je suština ponovljive analize.\n\n> Cilj čišćenja podataka nije savršenstvo. Cilj je da od neurednog, nekonzistentnog i djelomično nepoznatog skupa podataka stvorite skup koji je dovoljno uredan i dokumentiran da možete s povjerenjem raditi statističku analizu i transparentno komunicirati svaki izbor koji ste napravili.\n\n---\n\n::: {.callout-important}\n## Ključni zaključci\n\n1. Čišćenje i priprema podataka oduzima 80% vremena u bilo kojoj analizi. Stvarni podaci su gotovo uvijek neuredni i zahtijevaju sistematično čišćenje prije ikakve statističke analize.\n\n2. Funkcija `clean_names()` iz paketa janitor standardizira imena stupaca u snake_case format. Koristite je odmah nakon učitavanja svakog dataseta.\n\n3. `filter()` odabire retke po uvjetu. Automatski odbacuje retke s NA. Koristite `%in%` za provjeru pripadnosti skupu, `between()` za raspone i `str_detect()` za pretraživanje teksta.\n\n4. `select()` odabire, uklanja i preuređuje stupce. Pomoćne funkcije `starts_with()`, `ends_with()`, `contains()` i `where()` omogućuju pametan odabir. `rename()` mijenja imena bez gubitka stupaca.\n\n5. `mutate()` kreira nove stupce i transformira postojeće. `case_when()` je alat za složeno rekodiranje. `if_else()` za binarno. Razlika između 0 i NA je konceptualno važna.\n\n6. `arrange()` sortira retke. `desc()` za silazni smjer. NA uvijek na kraj.\n\n7. `group_by() |> summarise()` je temeljni obrazac za izračun statistika po grupama. Uvijek dodajte `.groups = \"drop\"`. `count()` je kratica za prebrojavanje.\n\n8. `across()` primjenjuje istu operaciju na više stupaca odjednom. Kombinira se i sa `summarise()` i s `mutate()`.\n\n9. `pivot_longer()` pretvara stupce u redove (široki u dugački format). `pivot_wider()` pretvara redove u stupce. Dugački format je pogodan za analizu i vizualizaciju, široki za prezentaciju.\n\n10. `left_join()` spaja dvije tablice po zajedničkom stupcu. Koristite ga kad trebate kombinirati podatke iz više izvora.\n\n11. stringr funkcije (`str_detect()`, `str_to_lower()`, `str_replace()`, `str_count()`) omogućuju rad s tekstualnim podacima. Bitne za čišćenje anketnih podataka.\n\n12. Svaka analiza ima jasne faze: učitavanje, čišćenje, provjera, analiza, prezentacija. Dokumentirajte svaki korak i svaki izbor (osobito koliko redova gubite filtiranjem).\n:::\n\n---\n\n::: {.callout-warning}\n## Priprema za sljedeći tjedan\n\nSljedeći tjedan bavimo se **deskriptivnom statistikom**: mjerama centralne tendencije (prosjek, medijan, mod), mjerama varijabilnosti (varijanca, standardna devijacija, IQR), korelacijama i standardnim rezultatima (z-scores). Sve ćemo raditi kroz `summarise()` i `group_by()` koje ste upravo naučili.\n\nZa pripremu napravite sljedeće:\n\n1. Ponovite kompletni pipeline čišćenja iz ovog predavanja. Pokrenite ga red po red i provjerite da razumijete svaki korak.\n2. Pokušajte odgovoriti na pitanje: razlikuje li se prosječno povjerenje u društvene mreže između ispitanika koji prate vijesti često i onih koji ne prate? (Hint: `mutate()` za kreiranje binarne varijable, `group_by() |> summarise()` za usporedbu.)\n3. Pretvorite podatke o korištenju (TV, portali, društvene mreže) u dugački format pomoću `pivot_longer()` i izračunajte prosječno korištenje po tipu medija i spolu.\n4. Pročitajte poglavlje 5 iz knjige Navarro (Learning Statistics with R) o deskriptivnoj statistici. Fokusirajte se na koncepte, ne na R kod (jer knjiga koristi base R).\n:::\n\n---\n\n## Dodatno čitanje\n\n**Obavezno**\n\nWickham, H. & Grolemund, G. (2023). *R for Data Science* (2nd edition), Chapters 4, 5 i 6. Besplatno dostupno na [r4ds.hadley.nz](https://r4ds.hadley.nz). Poglavlje 4 pokriva transformaciju podataka, poglavlje 5 organizaciju radnog toka, poglavlje 6 preoblikovanje podataka s pivot funkcijama.\n\nNavarro, D. (2018). *Learning Statistics with R*, Chapters 4 i 7. Besplatno dostupno na [learningstatisticswithr.com](https://learningstatisticswithr.com/lsr-0.6.pdf). Pokrivaju sličan teren u base R sintaksi.\n\n**Preporučeno**\n\nWickham, H. (2014). Tidy Data. *Journal of Statistical Software*, 59(10). Besplatno dostupno na [vita.had.co.nz/papers/tidy-data.pdf](https://vita.had.co.nz/papers/tidy-data.pdf). Klasičan rad koji definira princip urednih podataka.\n\nFirke, S. (2023). *janitor: Simple Tools for Examining and Cleaning Dirty Data*. Dokumentacija paketa na [sfirke.github.io/janitor](https://sfirke.github.io/janitor). Osim `clean_names()`, paket sadrži i `tabyl()` za brze tablice frekvencija i `remove_empty()` za uklanjanje praznih redova i stupaca.\n\n---\n\n## Pojmovnik\n\n| Pojam | Objašnjenje |\n|---|---|\n| dplyr | R paket iz tidyverse ekosustava za manipulaciju podacima. Sadrži glagole `filter()`, `select()`, `mutate()`, `summarise()`, `arrange()`, `group_by()` i druge. |\n| `filter()` | dplyr glagol za odabir redova koji zadovoljavaju logički uvjet. Automatski odbacuje retke s NA u uvjetu. |\n| `select()` | dplyr glagol za odabir, uklanjanje i preuređivanje stupaca. Podržava pomoćne funkcije poput `starts_with()`, `contains()` i `where()`. |\n| `mutate()` | dplyr glagol za kreiranje novih stupaca ili transformaciju postojećih. Novi stupci mogu referirati na upravo kreirane. |\n| `arrange()` | dplyr glagol za sortiranje redova po vrijednostima stupaca. `desc()` za silazno sortiranje. |\n| `summarise()` | dplyr glagol za sažimanje podataka u jednu vrijednost po grupi (ili za cijeli dataset). Koristi se s agregatnim funkcijama poput `mean()`, `sd()`, `n()`. |\n| `group_by()` | dplyr glagol koji dijeli podatke u grupe po jednoj ili više varijabli. Sve naknadne operacije se izvršavaju zasebno za svaku grupu. |\n| `ungroup()` | dplyr glagol koji uklanja grupiranje. Koristite nakon `group_by() |> mutate()` da izbjegnete neočekivano ponašanje. |\n| `count()` | Kratica za `group_by() |> summarise(n = n()) |> ungroup()`. Prebrojava opažanja po kategorijama. |\n| `across()` | Funkcija za primjenu iste operacije na više stupaca odjednom. Radi unutar `summarise()` i `mutate()`. |\n| `rename()` | dplyr glagol za preimenovanje stupaca bez gubitka ostalih. Sintaksa: `rename(novo = staro)`. |\n| `relocate()` | dplyr glagol za premještanje stupaca na drugu poziciju u datasetu. |\n| `case_when()` | Funkcija za složeno rekodiranje s više uvjeta. Svaki uvjet ima oblik `uvjet ~ vrijednost`. Provjerava uvjete redom. |\n| `if_else()` | Funkcija za binarno rekodiranje. Prima uvjet, vrijednost za TRUE i vrijednost za FALSE. |\n| `between()` | Pomoćna funkcija: provjera je li vrijednost unutar raspona. Kratica za `x >= left & x <= right`. |\n| `str_detect()` | stringr funkcija: provjerava sadrži li tekst zadani uzorak. Vraća TRUE/FALSE. |\n| `str_to_lower()` | stringr funkcija: pretvara tekst u mala slova. Korisna za standardizaciju. |\n| `str_replace()` | stringr funkcija: zamjenjuje prvo pojavljivanje uzorka u tekstu. `str_replace_all()` zamjenjuje sva. |\n| `str_count()` | stringr funkcija: broji pojavljivanja uzorka u tekstu. |\n| `pivot_longer()` | tidyr funkcija za pretvaranje stupaca u redove (široki u dugački format). Ključni argumenti: `cols`, `names_to`, `values_to`. |\n| `pivot_wider()` | tidyr funkcija za pretvaranje redova u stupce (dugački u široki format). Ključni argumenti: `names_from`, `values_from`. |\n| `left_join()` | dplyr funkcija za spajanje dviju tablica po zajedničkom stupcu. Zadržava sve retke iz lijeve tablice. |\n| `inner_join()` | Spajanje koje zadržava samo retke koji postoje u obje tablice. |\n| `anti_join()` | Spajanje koje zadržava retke iz lijeve tablice koji nemaju podudaranje u desnoj. Dijagnostički alat. |\n| `clean_names()` | janitor funkcija: pretvara imena stupaca u snake_case. Uklanja razmake, zagrade i specijalne znakove. |\n| `drop_na()` | tidyr funkcija za uklanjanje redova s NA. Može se primijeniti na cijeli dataset ili specifične stupce. |\n| Tidy data (uredni podaci) | Princip organizacije podataka: svaki redak je opažanje, svaki stupac varijabla, svaka ćelija vrijednost. |\n| Široki format | Organizacija podataka u kojoj su različita mjerenja iste varijable raspoređena u zasebne stupce. Čitljiv za ljude. |\n| Dugački format | Organizacija podataka u kojoj su različita mjerenja u zasebnim redovima s identifikacijskim stupcem. Pogodan za analizu i vizualizaciju. |\n| Pipeline | Niz operacija spojenih pipe operatorom (`|>`) koji transformira podatke korak po korak. |\n| Sirovi podaci (raw data) | Podaci u izvornom obliku, prije čišćenja. Ne bi ih trebalo mijenjati izravno. |\n| Čisti podaci (clean data) | Podaci nakon standardizacije, rekodiranja i provjere. Spremni za analizu. |\n| Rekodiranje | Pretvaranje vrijednosti varijable u standardizirani oblik (npr. svih varijanti spola u \"ženski\"/\"muški\"). |\n",
    "supporting": [
      "week-03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}